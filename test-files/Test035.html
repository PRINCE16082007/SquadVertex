<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Full Orbit Game ‚Äî Complete Build</title>
<style>
:root {
  --bg: #030916;
  --panel: #0a1833;
  --accent: #64c2ff;
  --good: #6affd1;
  --danger: #ff6b6b;
  --warning: #ffaa00;
  --text: #eaf6ff;
  --muted: #9fc9ff;
  --elite: #d400ff;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  user-select: none;
}

body {
  margin: 0;
  background: radial-gradient(circle at top, #071a38, #02060d 70%);
  color: var(--text);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

.container {
  max-width: 1200px;
  margin: auto;
  padding: 18px;
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

header {
  font-size: 1.4rem;
  font-weight: 900;
  margin-bottom: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.fullscreen-btn {
  background: linear-gradient(135deg, var(--accent), #0066cc);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 10px;
  font-weight: 700;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s;
  box-shadow: 0 4px 12px rgba(100, 194, 255, 0.3);
}

.fullscreen-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(100, 194, 255, 0.5);
}

.card {
  background: linear-gradient(180deg, #081b3a, #040b18);
  border-radius: 16px;
  padding: 14px;
  border: 1px solid rgba(255, 255, 255, 0.05);
  box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
  position: relative;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.play-area {
  position: relative;
  flex-grow: 1;
  min-height: 500px;
  border-radius: 14px;
  overflow: hidden;
  background: radial-gradient(circle, #0a2244, #02060d);
  display: flex;
  align-items: center;
  justify-content: center;
}

canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
}

.earth {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-size: 70px;
  filter: drop-shadow(0 0 28px rgba(100, 194, 255, 0.8));
  pointer-events: none;
  z-index: 1;
}

.hud {
  position: absolute;
  right: 16px;
  top: 16px;
  background: rgba(6, 16, 32, 0.85);
  padding: 14px 18px;
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  gap: 20px;
  backdrop-filter: blur(10px);
  z-index: 100;
}

.hud div {
  text-align: center;
  min-width: 80px;
}

.hud strong {
  font-size: 1.5rem;
  display: block;
  margin-bottom: 4px;
  font-weight: 800;
}

.hud span {
  font-size: 0.8rem;
  color: var(--muted);
  font-weight: 600;
}

.ai-display {
  position: absolute;
  left: 16px;
  top: 16px;
  background: rgba(255, 255, 255, 0.08);
  padding: 10px 14px;
  border-radius: 10px;
  font-size: 0.85rem;
  border: 1px solid rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(10px);
  z-index: 100;
}

.combo-display {
  position: absolute;
  left: 50%;
  bottom: 24px;
  transform: translateX(-50%);
  font-weight: 900;
  color: var(--good);
  font-size: 2rem;
  opacity: 0;
  transition: all 0.3s;
  text-shadow: 0 0 20px var(--good);
  pointer-events: none;
  z-index: 100;
}

.combo-display.show {
  opacity: 1;
  transform: translateX(-50%) scale(1.2);
}

.difficulty-bar {
  position: absolute;
  bottom: 16px;
  left: 16px;
  background: rgba(0, 0, 0, 0.6);
  padding: 8px 14px;
  border-radius: 10px;
  font-size: 0.85rem;
  border: 2px solid;
  color: var(--accent);
  pointer-events: none;
  font-weight: 700;
  backdrop-filter: blur(5px);
  z-index: 100;
}

.boss-timer {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.2rem;
  font-weight: 900;
  color: var(--danger);
  opacity: 0;
  pointer-events: none;
  text-shadow: 0 0 15px var(--danger);
  z-index: 200;
  text-align: center;
  transition: opacity 0.3s;
}

.boss-timer.active {
  opacity: 1;
  animation: pulse 1s infinite;
}

.warning {
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.3rem;
  font-weight: 800;
  color: var(--danger);
  opacity: 0;
  pointer-events: none;
  text-shadow: 0 0 10px var(--danger);
  z-index: 200;
  text-align: center;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid var(--danger);
  transition: opacity 0.3s;
}

.warning.active {
  opacity: 1;
  animation: shake 0.5s ease-in-out;
}

.explosion {
  position: absolute;
  pointer-events: none;
  z-index: 50;
}

#rotatePrompt {
  position: fixed;
  inset: 0;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 10000;
  color: white;
  font-size: 1.4rem;
  font-weight: bold;
  text-align: center;
  padding: 20px;
  display: none;
}

#rotatePrompt div {
  margin-top: 20px;
  color: var(--accent);
  font-size: 1rem;
}

.pause-menu {
  position: fixed;
  inset: 0;
  background: rgba(0, 5, 15, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 1000;
  color: white;
  display: none;
  backdrop-filter: blur(10px);
}

.pause-menu h2 {
  font-size: 2.5rem;
  margin-bottom: 30px;
  color: var(--accent);
  text-shadow: 0 0 15px var(--accent);
}

.pause-menu button {
  background: linear-gradient(135deg, var(--accent), #0066cc);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 10px;
  font-size: 1.1rem;
  font-weight: 700;
  cursor: pointer;
  margin: 10px;
  min-width: 200px;
  transition: all 0.3s;
}

.pause-menu button:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 20px rgba(100, 194, 255, 0.5);
}

.powerup-indicator {
  position: absolute;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.2rem;
  font-weight: 800;
  padding: 8px 16px;
  border-radius: 8px;
  opacity: 0;
  transition: opacity 0.3s;
  z-index: 150;
  text-align: center;
}

.stats-panel {
  position: absolute;
  bottom: 16px;
  right: 16px;
  background: rgba(0, 0, 0, 0.6);
  padding: 10px 14px;
  border-radius: 10px;
  font-size: 0.8rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
  pointer-events: none;
  backdrop-filter: blur(5px);
  z-index: 100;
}

@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.1); }
}

@keyframes shake {
  0%, 100% { transform: translateX(-50%); }
  25% { transform: translateX(calc(-50% - 5px)); }
  75% { transform: translateX(calc(-50% + 5px)); }
}

@keyframes orbit {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@media (max-width: 768px) {
  .container {
    padding: 10px;
  }
  
  header {
    font-size: 1.1rem;
  }
  
  .hud {
    flex-direction: column;
    gap: 10px;
    padding: 10px 12px;
    right: 10px;
    top: 10px;
  }
  
  .hud div {
    min-width: 60px;
  }
  
  .hud strong {
    font-size: 1.2rem;
  }
  
  .ai-display {
    font-size: 0.75rem;
    padding: 8px 12px;
    left: 10px;
    top: 10px;
  }
  
  .boss-timer {
    font-size: 1.5rem;
  }
  
  .warning {
    font-size: 1rem;
    top: 15%;
  }
  
  .earth {
    font-size: 50px;
  }
}

@media (max-width: 480px) {
  .hud {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    width: calc(100% - 20px);
    right: 10px;
  }
  
  .hud div {
    min-width: auto;
    flex: 1;
  }
}
</style>
</head>
<body>

<div id="rotatePrompt">
  üì± Please rotate your device<br>to landscape mode!<br>
  <div>Then tap anywhere to continue</div>
</div>

<div class="pause-menu" id="pauseMenu">
  <h2>‚è∏Ô∏è GAME PAUSED</h2>
  <button id="resumeBtn">‚ñ∂Ô∏è Resume Game</button>
  <button id="restartBtn">üîÑ Restart Game</button>
  <button id="menuBtn">üè† Back to Menu</button>
  <div style="margin-top: 30px; color: var(--muted); font-size: 0.9rem;">
    High Score: <span id="highScoreDisplay">0</span>
  </div>
</div>

<div class="container">
<header>
  <span>üåå Full Orbit Game ‚Äî Elite Edition</span>
  <div>
    <button class="fullscreen-btn" id="fsBtn">‚õ∂ Fullscreen</button>
    <button class="fullscreen-btn" id="pauseBtn" style="margin-left: 10px; background: linear-gradient(135deg, var(--warning), #cc5500);">‚è∏Ô∏è Pause</button>
  </div>
</header>

<div class="card">
<div class="play-area">
<canvas id="gameCanvas"></canvas>
<div class="earth">üåç</div>

<div class="ai-display" id="aiDisplay">AI: Initializing...</div>
<div class="difficulty-bar" id="diffBar">Level: Easy</div>
<div class="boss-timer" id="bossTimer">üëë BOSS INCOMING!</div>
<div class="warning" id="warning">‚ö†Ô∏è AVOID THE ALIEN!</div>
<div class="powerup-indicator" id="powerupIndicator"></div>

<div class="hud">
  <div><strong id="score">0</strong><span>Score</span></div>
  <div><strong id="comboVal">0</strong><span>Combo</span></div>
  <div><strong id="misses">0</strong><span>Misses</span></div>
  <div><strong id="accuracy">100%</strong><span>Accuracy</span></div>
</div>

<div class="combo-display" id="comboText">COMBO!</div>

<div class="stats-panel">
  Objects: <span id="objectCount">0</span> | FPS: <span id="fpsCounter">60</span>
</div>
</div>
</div>
</div>

<script>
// ================= GLOBAL VARIABLES =================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("comboVal");
const missEl = document.getElementById("misses");
const accuracyEl = document.getElementById("accuracy");
const aiEl = document.getElementById("aiDisplay");
const diffBar = document.getElementById("diffBar");
const bossTimer = document.getElementById("bossTimer");
const warning = document.getElementById("warning");
const comboText = document.getElementById("comboText");
const powerupIndicator = document.getElementById("powerupIndicator");
const objectCountEl = document.getElementById("objectCount");
const fpsCounterEl = document.getElementById("fpsCounter");
const pauseMenu = document.getElementById("pauseMenu");
const pauseBtn = document.getElementById("pauseBtn");
const resumeBtn = document.getElementById("resumeBtn");
const restartBtn = document.getElementById("restartBtn");
const menuBtn = document.getElementById("menuBtn");
const highScoreDisplay = document.getElementById("highScoreDisplay");
const rotatePrompt = document.getElementById("rotatePrompt");

let W, H, DPR;
let gameActive = true;
let isPaused = false;
let isFullscreen = false;
let frameCount = 0;
let lastFpsUpdate = 0;
let fps = 60;

// Game state
let orbs = [];
let aliens = [];
let bombs = [];
let bosses = [];
let powerups = [];
let explosions = [];
let score = 0;
let combo = 0;
let misses = 0;
let clicks = 0;
let hits = 0;
let reactionTimes = [];
let lastBossTime = Date.now();
let isDistorting = false;
let distortionIntensity = 0;
let distortionDuration = 0;
let activePowerup = null;
let powerupEndTime = 0;

// Power-up types
const POWERUPS = [
  { emoji: "‚ö°", name: "Speed Boost", color: "#ffff00", duration: 8000, effect: "speed" },
  { emoji: "üõ°Ô∏è", name: "Invincibility", color: "#00ff00", duration: 5000, effect: "invincible" },
  { emoji: "üí∞", name: "Double Points", color: "#ffd700", duration: 10000, effect: "double" },
  { emoji: "üåÄ", name: "Time Slow", color: "#9370db", duration: 6000, effect: "slow" }
];

// High score
let highScore = localStorage.getItem('orbitHighScore') || 0;
highScoreDisplay.textContent = highScore;

// ================= INITIALIZATION =================
function init() {
  resizeCanvas();
  setupEventListeners();
  gameLoop();
  spawnLoop();
}

function resizeCanvas() {
  DPR = Math.max(1, window.devicePixelRatio || 1);
  W = canvas.offsetWidth;
  H = canvas.offsetHeight;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}

function setupEventListeners() {
  window.addEventListener("resize", resizeCanvas);
  
  // Fullscreen
  document.getElementById("fsBtn").addEventListener("click", enterFullscreen);
  document.addEventListener("fullscreenchange", handleFullscreenChange);
  
  // Pause menu
  pauseBtn.addEventListener("click", togglePause);
  resumeBtn.addEventListener("click", togglePause);
  restartBtn.addEventListener("click", restartGame);
  menuBtn.addEventListener("click", () => {
    if (confirm("Return to menu? Your current game will be lost.")) {
      window.location.reload();
    }
  });
  
  // Game controls
  canvas.addEventListener("pointerdown", handleClick);
  document.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "Escape") {
      togglePause();
    }
  });
  
  // Mobile rotation
  document.addEventListener("pointerdown", () => {
    if (rotatePrompt.style.display === "flex") {
      rotatePrompt.style.display = "none";
    }
  });
  
  window.addEventListener("orientationchange", checkOrientation);
}

// ================= FULLSCREEN & ORIENTATION =================
function enterFullscreen() {
  const elem = document.documentElement;
  if (elem.requestFullscreen) elem.requestFullscreen();
  else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
  else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
}

function handleFullscreenChange() {
  isFullscreen = !!document.fullscreenElement;
  if (isFullscreen) {
    document.querySelector("header").style.display = "none";
    document.querySelector(".container").style.padding = "0";
    document.body.style.background = "black";
    
    // Check mobile orientation
    if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      setTimeout(() => {
        if (window.innerWidth < window.innerHeight) {
          rotatePrompt.style.display = "flex";
        }
      }, 500);
    }
  } else {
    document.querySelector("header").style.display = "flex";
    document.querySelector(".container").style.padding = "18px";
    document.body.style.background = "";
    rotatePrompt.style.display = "none";
  }
  resizeCanvas();
}

function checkOrientation() {
  if (isFullscreen && window.innerWidth < window.innerHeight) {
    rotatePrompt.style.display = "flex";
  } else {
    rotatePrompt.style.display = "none";
  }
}

// ================= GAME STATE MANAGEMENT =================
function togglePause() {
  isPaused = !isPaused;
  pauseMenu.style.display = isPaused ? "flex" : "none";
  pauseBtn.textContent = isPaused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
}

function restartGame() {
  if (confirm("Restart game? Current progress will be lost.")) {
    orbs = []; aliens = []; bombs = []; bosses = []; powerups = []; explosions = [];
    score = 0; combo = 0; misses = 0; clicks = 0; hits = 0; reactionTimes = [];
    activePowerup = null;
    lastBossTime = Date.now();
    updateDisplay();
    togglePause();
  }
}

function saveHighScore() {
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('orbitHighScore', highScore);
    highScoreDisplay.textContent = highScore;
  }
}

// ================= SKILL & DIFFICULTY SYSTEM =================
function calculateSkillIndex() {
  const accuracy = hits / Math.max(1, clicks);
  const avgReaction = reactionTimes.length > 0 ? 
    reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length : 1000;
  const reactionScore = Math.max(0, 1 - avgReaction / 1200);
  const comboBonus = Math.min(1, combo / 50);
  
  return Math.min(1, (accuracy * 0.5 + reactionScore * 0.3 + comboBonus * 0.2));
}

function getDifficultyLevel(skill) {
  if (skill < 0.2) return { level: "Easy", color: "#6affd1", orbCount: 12, speed: 0.0025, shieldProb: 0.1, spawnRate: 1200 };
  if (skill < 0.4) return { level: "Medium", color: "#64c2ff", orbCount: 15, speed: 0.004, shieldProb: 0.15, spawnRate: 900 };
  if (skill < 0.6) return { level: "Hard", color: "#ffaa00", orbCount: 18, speed: 0.006, shieldProb: 0.2, spawnRate: 700 };
  if (skill < 0.8) return { level: "Pro", color: "#ff6b6b", orbCount: 22, speed: 0.008, shieldProb: 0.25, spawnRate: 500 };
  return { level: "Elite", color: "#d400ff", orbCount: 25, speed: 0.01, shieldProb: 0.3, spawnRate: 400 };
}

// ================= SPAWNING SYSTEM =================
function spawnLoop() {
  if (!gameActive || isPaused) return;
  
  const skill = calculateSkillIndex();
  const diff = getDifficultyLevel(skill);
  
  // Update display
  diffBar.textContent = `Level: ${diff.level}`;
  diffBar.style.color = diff.color;
  diffBar.style.borderColor = diff.color;
  
  // Spawn orbs
  if (orbs.length < diff.orbCount) {
    const types = [
      { emoji: "ü™®", score: 1 },
      { emoji: "üíé", score: 3 },
      { emoji: "üåü", score: 5 },
      { emoji: "üõ°Ô∏è", score: 8, shield: true }
    ];
    
    const type = types[Math.floor(Math.random() * types.length)];
    let speed = diff.speed + Math.random() * 0.002;
    speed = Math.min(speed, 0.012);
    
    orbs.push({
      type: 'orb',
      angle: Math.random() * Math.PI * 2,
      radius: 90 + skill * 100 + Math.random() * 80,
      speed: (Math.random() < 0.5 ? -1 : 1) * speed,
      size: 32,
      emoji: type.emoji,
      score: type.score,
      shield: type.shield || Math.random() < diff.shieldProb,
      shieldHP: (type.shield || Math.random() < diff.shieldProb) ? 2 : 0,
      spawnTime: Date.now()
    });
  }
  
  // Spawn alien (with warning)
  if (Math.random() < 0.003 && aliens.length === 0) {
    warning.classList.add("active");
    setTimeout(() => warning.classList.remove("active"), 2000);
    
    aliens.push({
      type: 'alien',
      angle: Math.random() * Math.PI * 2,
      radius: 140 + Math.random() * 100,
      speed: (Math.random() < 0.5 ? -1 : 1) * 0.006,
      size: 45,
      emoji: "üëæ",
      glow: true,
      spawnTime: Date.now()
    });
  }
  
  // Spawn bomb
  if (Math.random() < 0.002 && bombs.length === 0) {
    bombs.push({
      type: 'bomb',
      angle: Math.random() * Math.PI * 2,
      radius: 160 + Math.random() * 80,
      speed: (Math.random() < 0.5 ? -1 : 1) * 0.004,
      size: 36,
      emoji: "üí£",
      glow: true,
      spawnTime: Date.now()
    });
  }
  
  // Spawn power-up
  if (Math.random() < 0.001 && powerups.length === 0 && !activePowerup) {
    const powerup = POWERUPS[Math.floor(Math.random() * POWERUPS.length)];
    powerups.push({
      type: 'powerup',
      angle: Math.random() * Math.PI * 2,
      radius: 110 + Math.random() * 60,
      speed: (Math.random() < 0.5 ? -1 : 1) * 0.003,
      size: 28,
      emoji: powerup.emoji,
      name: powerup.name,
      color: powerup.color,
      effect: powerup.effect,
      duration: powerup.duration,
      spawnTime: Date.now()
    });
  }
  
  // Spawn boss (every 90 seconds)
  if (Date.now() - lastBossTime > 90000 && bosses.length === 0) {
    bossTimer.classList.add("active");
    setTimeout(() => {
      bossTimer.classList.remove("active");
      
      bosses.push({
        type: 'boss',
        cores: [
          { angle: 0, active: true, hit: false },
          { angle: Math.PI * 2/3, active: true, hit: false },
          { angle: Math.PI * 4/3, active: true, hit: false }
        ],
        health: 3,
        size: 110,
        radius: 180,
        angle: 0,
        speed: 0.0015,
        spawnTime: Date.now()
      });
      lastBossTime = Date.now();
    }, 3000);
  }
  
  setTimeout(spawnLoop, diff.spawnRate);
}

// ================= INPUT HANDLING =================
function handleClick(e) {
  if (!gameActive || isPaused) return;
  
  clicks++;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cx = W / 2;
  const cy = H / 2;
  
  let hit = false;
  
  // Check aliens first (priority)
  for (let i = aliens.length - 1; i >= 0; i--) {
    const a = aliens[i];
    const ax = cx + Math.cos(a.angle) * a.radius;
    const ay = cy + Math.sin(a.angle) * a.radius;
    const d = Math.hypot(x - ax, y - ay);
    
    if (d < a.size) {
      triggerAlienPunishment();
      aliens.splice(i, 1);
      createExplosion(ax, ay, "red");
      hit = true;
      break;
    }
  }
  
  if (hit) return;
  
  // Check bombs
  for (let i = bombs.length - 1; i >= 0; i--) {
    const b = bombs[i];
    const bx = cx + Math.cos(b.angle) * b.radius;
    const by = cy + Math.sin(b.angle) * b.radius;
    const d = Math.hypot(x - bx, y - by);
    
    if (d < b.size) {
      triggerBombExplosion(bx, by);
      bombs.splice(i, 1);
      hits++;
      hit = true;
      break;
    }
  }
  
  if (hit) return;
  
  // Check orbs
  for (let i = orbs.length - 1; i >= 0; i--) {
    const o = orbs[i];
    const ox = cx + Math.cos(o.angle) * o.radius;
    const oy = cy + Math.sin(o.angle) * o.radius;
    const d = Math.hypot(x - ox, y - oy);
    
    if (d < o.size) {
      if (o.shield && o.shieldHP > 0) {
        o.shieldHP--;
        createExplosion(ox, oy, "#6affd1", 15);
        return;
      }
      
      hits++;
      reactionTimes.push(Date.now() - o.spawnTime);
      
      const points = activePowerup?.effect === "double" ? o.score * 2 : o.score;
      score += points;
      combo++;
      
      orbs.splice(i, 1);
      createExplosion(ox, oy, "#ffffff", 20);
      
      hit = true;
      break;
    }
  }
  
  if (hit) {
    updateDisplay();
    showCombo();
    return;
  }
  
  // Check power-ups
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    const px = cx + Math.cos(p.angle) * p.radius;
    const py = cy + Math.sin(p.angle) * p.radius;
    const d = Math.hypot(x - px, y - py);
    
    if (d < p.size) {
      activatePowerup(p);
      powerups.splice(i, 1);
      createExplosion(px, py, p.color, 25);
      hits++;
      return;
    }
  }
  
  // Check boss cores
  for (let boss of bosses) {
    for (let i = 0; i < boss.cores.length; i++) {
      const core = boss.cores[i];
      if (!core.active || core.hit) continue;
      
      const totalAngle = boss.angle + core.angle;
      const bx = cx + Math.cos(totalAngle) * boss.radius;
      const by = cy + Math.sin(totalAngle) * boss.radius;
      const d = Math.hypot(x - bx, y - by);
      
      if (d < boss.size / 2.5) {
        core.hit = true;
        core.active = false;
        boss.health--;
        
        createExplosion(bx, by, "#ff00ff", 30);
        
        if (boss.health <= 0) {
          // Boss defeated!
          const bonus = Math.floor(100 * calculateSkillIndex());
          score += bonus;
          combo += 15;
          
          createExplosion(cx, cy, "#ffd700", 100);
          
          // Guaranteed bomb spawn
          setTimeout(() => {
            bombs.push({
              type: 'bomb',
              angle: Math.random() * Math.PI * 2,
              radius: 180 + Math.random() * 60,
              speed: (Math.random() < 0.5 ? -1 : 1) * 0.004,
              size: 36,
              emoji: "üí£",
              glow: true,
              spawnTime: Date.now()
            });
          }, 500);
          
          bosses = [];
        }
        
        hits++;
        updateDisplay();
        return;
      }
    }
  }
  
  // Miss
  combo = 0;
  misses++;
  updateDisplay();
}

// ================= SPECIAL EFFECTS =================
function triggerAlienPunishment() {
  const penalty = Math.max(10, Math.floor(score * 0.1));
  score = Math.max(0, score - penalty);
  combo = Math.max(0, combo - Math.floor(combo * 0.1));
  
  isDistorting = true;
  distortionIntensity = 0.1;
  distortionDuration = 2000;
  
  updateDisplay();
  
  // Show penalty message
  aiEl.textContent = `Alien Hit! -${penalty} points`;
  aiEl.style.color = "#ff6b6b";
  setTimeout(() => {
    aiEl.style.color = "";
  }, 2000);
}

function triggerBombExplosion(x, y) {
  const blastRadius = 180;
  const cx = W / 2;
  const cy = H / 2;
  
  // Destroy nearby orbs
  orbs = orbs.filter(o => {
    const ox = cx + Math.cos(o.angle) * o.radius;
    const oy = cy + Math.sin(o.angle) * o.radius;
    const d = Math.hypot(x - ox, y - oy);
    return d > blastRadius;
  });
  
  // Break shields on remaining orbs
  orbs.forEach(o => {
    if (o.shieldHP > 0) {
      o.shieldHP = 0;
      createExplosion(cx + Math.cos(o.angle) * o.radius, cy + Math.sin(o.angle) * o.radius, "#ffaa00", 10);
    }
  });
  
  // Remove nearby aliens and bombs
  aliens = aliens.filter(a => {
    const ax = cx + Math.cos(a.angle) * a.radius;
    const ay = cy + Math.sin(a.angle) * a.radius;
    return Math.hypot(x - ax, y - ay) > blastRadius;
  });
  
  bombs = bombs.filter(b => {
    const bx = cx + Math.cos(b.angle) * b.radius;
    const by = cy + Math.sin(b.angle) * b.radius;
    return Math.hypot(x - bx, y - by) > blastRadius;
  });
  
  createExplosion(x, y, "#ff8800", 80);
}

function activatePowerup(powerup) {
  activePowerup = {
    effect: powerup.effect,
    name: powerup.name,
    color: powerup.color,
    endTime: Date.now() + powerup.duration
  };
  powerupEndTime = Date.now() + powerup.duration;
  
  // Visual feedback
  powerupIndicator.textContent = `${powerup.emoji} ${powerup.name} ACTIVATED!`;
  powerupIndicator.style.color = powerup.color;
  powerupIndicator.style.opacity = "1";
  powerupIndicator.style.backgroundColor = "rgba(0,0,0,0.7)";
  
  setTimeout(() => {
    powerupIndicator.style.opacity = "0";
  }, 2000);
}

function createExplosion(x, y, color, size = 30) {
  explosions.push({
    x, y, color, size,
    maxSize: size,
    growth: 2,
    alpha: 1,
    duration: 500
  });
}

// ================= DISPLAY UPDATES =================
function updateDisplay() {
  scoreEl.textContent = score;
  comboEl.textContent = combo;
  missEl.textContent = misses;
  
  const accuracy = hits / Math.max(1, clicks) * 100;
  accuracyEl.textContent = `${accuracy.toFixed(0)}%`;
  
  const skill = calculateSkillIndex();
  aiEl.textContent = `AI Skill: ${skill.toFixed(2)} | Objects: ${orbs.length + aliens.length + bombs.length + powerups.length + bosses.length}`;
  
  // Update high score if needed
  if (score > highScore) {
    saveHighScore();
  }
  
  objectCountEl.textContent = orbs.length + aliens.length + bombs.length + powerups.length + bosses.length;
}

function showCombo() {
  if (combo > 5) {
    comboText.textContent = `${combo} COMBO!`;
    comboText.style.color = combo >= 20 ? "#ff00ff" : combo >= 10 ? "#ffaa00" : "#6affd1";
    comboText.classList.add("show");
    
    setTimeout(() => {
      comboText.classList.remove("show");
    }, 500);
  }
}

// ================= RENDERING =================
function gameLoop(timestamp) {
  if (!gameActive) return;
  
  frameCount++;
  if (timestamp - lastFpsUpdate >= 1000) {
    fps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));
    fpsCounterEl.textContent = fps;
    frameCount = 0;
    lastFpsUpdate = timestamp;
  }
  
  if (isPaused) {
    requestAnimationFrame(gameLoop);
    return;
  }
  
  // Apply screen distortion if active
  if (isDistorting) {
    ctx.save();
    const wave = Math.sin(Date.now() / 80) * distortionIntensity;
    ctx.transform(1 + wave, wave * 0.3, wave * 0.3, 1 + wave, 0, 0);
    ctx.fillStyle = `rgba(255, 50, 50, ${distortionIntensity * 0.3})`;
    ctx.fillRect(0, 0, W, H);
    
    distortionDuration -= 16;
    if (distortionDuration <= 0) {
      isDistorting = false;
    }
  }
  
  // Clear canvas with fade effect
  ctx.fillStyle = "rgba(10, 20, 40, 0.1)";
  ctx.fillRect(0, 0, W, H);
  
  const cx = W / 2;
  const cy = H / 2;
  
  // Draw orbit rings (visual only)
  ctx.strokeStyle = "rgba(100, 194, 255, 0.05)";
  ctx.lineWidth = 1;
  for (let r = 80; r <= 300; r += 40) {
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Draw orbs
  orbs.forEach(orb => {
    orb.angle += orb.speed;
    const x = cx + Math.cos(orb.angle) * orb.radius;
    const y = cy + Math.sin(orb.angle) * orb.radius;
    
    // Draw shield if active
    if (orb.shield && orb.shieldHP > 0) {
      ctx.beginPath();
      ctx.arc(x, y, orb.size + 8, 0, Math.PI * 2);
      ctx.strokeStyle = "#6affd1";
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Shield text
      ctx.font = "bold 16px Arial";
      ctx.fillStyle = "#6affd1";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(orb.shieldHP, x, y - orb.size - 15);
    }
    
    // Draw orb
    ctx.font = `${orb.size}px serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(orb.emoji, x, y);
  });
  
  // Draw aliens
  aliens.forEach(alien => {
    alien.angle += alien.speed;
    const x = cx + Math.cos(alien.angle) * alien.radius;
    const y = cy + Math.sin(alien.angle) * alien.radius;
    
    // Glow effect
    if (alien.glow) {
      ctx.shadowColor = "red";
      ctx.shadowBlur = 20;
    }
    
    ctx.font = `${alien.size}px serif`;
    ctx.fillStyle = "white";
    ctx.fillText(alien.emoji, x, y);
    
    ctx.shadowBlur = 0;
  });
  
  // Draw bombs
  bombs.forEach(bomb => {
    bomb.angle += bomb.speed;
    const x = cx + Math.cos(bomb.angle) * bomb.radius;
    const y = cy + Math.sin(bomb.angle) * bomb.radius;
    
    // Glow effect
    if (bomb.glow) {
      ctx.shadowColor = "orange";
      ctx.shadowBlur = 15;
    }
    
    ctx.font = `${bomb.size}px serif`;
    ctx.fillStyle = "white";
    ctx.fillText(bomb.emoji, x, y);
    
    ctx.shadowBlur = 0;
  });
  
  // Draw power-ups
  powerups.forEach(p => {
    p.angle += p.speed;
    const x = cx + Math.cos(p.angle) * p.radius;
    const y = cy + Math.sin(p.angle) * p.radius;
    
    // Pulsing effect
    const pulse = Math.sin(Date.now() / 200) * 3;
    
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 15;
    ctx.font = `${p.size + pulse}px serif`;
    ctx.fillStyle = "white";
    ctx.fillText(p.emoji, x, y);
    ctx.shadowBlur = 0;
  });
  
  // Draw bosses
  bosses.forEach(boss => {
    boss.angle += boss.speed;
    
    // Draw boss crown
    ctx.font = `${boss.size}px serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "#ff00ff";
    ctx.shadowBlur = 25;
    ctx.fillText("üëë", cx, cy);
    ctx.shadowBlur = 0;
    
    // Draw health bar
    ctx.fillStyle = "#333";
    ctx.fillRect(cx - 50, cy - boss.size - 20, 100, 8);
    ctx.fillStyle = boss.health > 1 ? "#00ff00" : "#ff0000";
    ctx.fillRect(cx - 50, cy - boss.size - 20, (boss.health / 3) * 100, 8);
    
    // Draw cores
    boss.cores.forEach((core, i) => {
      if (!core.active) return;
      
      const totalAngle = boss.angle + core.angle;
      const x = cx + Math.cos(totalAngle) * boss.radius;
      const y = cy + Math.sin(totalAngle) * boss.radius;
      
      // Pulsing core
      const pulse = core.hit ? 0 : Math.sin(Date.now() / 300 + i) * 5;
      
      if (!core.hit) {
        ctx.shadowColor = "#ff5500";
        ctx.shadowBlur = 15;
      }
      
      ctx.font = `${boss.size / 1.8 + pulse}px serif`;
      ctx.fillStyle = core.hit ? "#666" : "white";
      ctx.fillText("üí•", x, y);
      
      ctx.shadowBlur = 0;
    });
  });
  
  // Draw explosions
  for (let i = explosions.length - 1; i >= 0; i--) {
    const exp = explosions[i];
    
    ctx.beginPath();
    ctx.arc(exp.x, exp.y, exp.size, 0, Math.PI * 2);
    ctx.fillStyle = exp.color.replace(")", `, ${exp.alpha})`).replace("rgb", "rgba");
    ctx.fill();
    
    exp.size += exp.growth;
    exp.alpha -= 0.02;
    exp.duration -= 16;
    
    if (exp.duration <= 0 || exp.alpha <= 0) {
      explosions.splice(i, 1);
    }
  }
  
  // Draw active power-up timer
  if (activePowerup && Date.now() < powerupEndTime) {
    const timeLeft = powerupEndTime - Date.now();
    const percent = timeLeft / 10000;
    
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(10, H - 40, 200, 25);
    ctx.fillStyle = activePowerup.color;
    ctx.fillRect(10, H - 40, 200 * percent, 25);
    
    ctx.font = "bold 14px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "left";
    ctx.fillText(`${activePowerup.emoji} ${activePowerup.name}: ${(timeLeft/1000).toFixed(1)}s`, 15, H - 23);
  } else if (activePowerup) {
    activePowerup = null;
  }
  
  // Restore context after distortion
  if (isDistorting) {
    ctx.restore();
  }
  
  requestAnimationFrame(gameLoop);
}

// ================= START GAME =================
window.addEventListener("load", () => {
  init();
  updateDisplay();
});
</script>
</body>
</html>
