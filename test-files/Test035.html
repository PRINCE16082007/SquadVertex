<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Full Orbit Game ‚Äî Intelligent Fun Build</title>

<style>
:root{
  --bg:#030916;
  --panel:#0a1833;
  --accent:#64c2ff;
  --good:#6affd1;
  --danger:#ff6b6b;
  --text:#eaf6ff;
  --muted:#9fc9ff;
}
*{box-sizing:border-box;margin:0;padding:0}
body{
  margin:0;
  background:radial-gradient(circle at top,#071a38,#02060d 70%);
  color:var(--text);
  font-family:Inter,Poppins,Arial,sans-serif;
  overflow:hidden; /* prevent scroll in fullscreen */
}
.container{
  max-width:1200px;
  margin:auto;
  padding:18px;
}
header{
  font-size:1.4rem;
  font-weight:900;
  margin-bottom:12px;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
.fullscreen-btn {
  background:var(--accent);
  color:#000;
  border:none;
  padding:4px 10px;
  border-radius:8px;
  font-weight:700;
  cursor:pointer;
  font-size:0.9rem;
}
.card{
  background:linear-gradient(180deg,#081b3a,#040b18);
  border-radius:16px;
  padding:14px;
  border:1px solid rgba(255,255,255,.05);
  box-shadow:0 30px 60px rgba(0,0,0,.8);
  position:relative;
}
.play{
  position:relative;
  height:560px;
  border-radius:14px;
  overflow:hidden;
  background:radial-gradient(circle,#0a2244,#02060d);
}
canvas{position:absolute;inset:0;width:100%;height:100%}
.earth{
  position:absolute;
  left:50%;top:50%;
  transform:translate(-50%,-50%);
  font-size:66px;
  filter:drop-shadow(0 0 28px rgba(100,194,255,.8));
}
.hud{
  position:absolute;
  right:16px;top:16px;
  background:rgba(6,16,32,.75);
  padding:12px 16px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.06);
  display:flex;
  gap:16px;
}
.hud div{text-align:right}
.hud strong{font-size:1.1rem}
.hud span{font-size:.75rem;color:var(--muted)}

.ai{
  position:absolute;
  left:16px;top:16px;
  background:rgba(255,255,255,.05);
  padding:8px 12px;
  border-radius:10px;
  font-size:.78rem;
  border:1px solid rgba(255,255,255,.08);
}
.combo{
  position:absolute;
  left:50%;
  bottom:18px;
  transform:translateX(-50%);
  font-weight:800;
  color:var(--good);
  opacity:0;
  transition:.2s;
}
.combo.show{opacity:1}

/* Fullscreen overlay for mobile orientation prompt */
#rotatePrompt {
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  z-index:10000;
  color:white;
  font-size:1.2rem;
  font-weight:bold;
  display:none;
}
#rotatePrompt div {
  margin-top:20px;
  color:var(--accent);
}
</style>
</head>

<body>

<div id="rotatePrompt">
  üì± Please rotate your device<br>to landscape mode!<br>
  <div>Then tap anywhere to continue</div>
</div>

<div class="container">
<header>
  <span>üåå Full Orbit Game ‚Äî Intelligent Fun Build</span>
  <button class="fullscreen-btn" id="fsBtn">‚õ∂ Fullscreen</button>
</header>

<div class="card">
<div class="play">
<canvas id="c"></canvas>
<div class="earth">üåç</div>

<div class="ai" id="ai">AI: calibrating‚Ä¶</div>

<div class="hud">
  <div><strong id="score">0</strong><br><span>Score</span></div>
  <div><strong id="comboVal">0</strong><br><span>Combo</span></div>
  <div><strong id="misses">0</strong><br><span>Misses</span></div>
</div>

<div class="combo" id="comboText">COMBO!</div>
</div>
</div>
</div>

<script>
/* ================= FULLSCREEN + ORIENTATION ================= */
const fsBtn = document.getElementById('fsBtn');
const rotatePrompt = document.getElementById('rotatePrompt');
const gameCard = document.querySelector('.card');

let isFullscreen = false;

// Check if device is mobile
const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

function enterFullscreen() {
  const elem = document.documentElement;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { // Safari
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { // IE11
    elem.msRequestFullscreen();
  }
}

function lockLandscape() {
  if (!screen.orientation) return false;
  try {
    // Attempt to lock to landscape
    return screen.orientation.lock('landscape').then(() => true).catch(() => false);
  } catch (e) {
    return false;
  }
}

function showRotatePrompt() {
  rotatePrompt.style.display = 'flex';
  document.body.style.overflow = 'hidden';
}

function hideRotatePrompt() {
  rotatePrompt.style.display = 'none';
  document.body.style.overflow = '';
}

fsBtn?.addEventListener('click', async () => {
  if (isFullscreen) return; // Already handled internally
  enterFullscreen();
});

document.addEventListener('fullscreenchange', async () => {
  isFullscreen = !!document.fullscreenElement;
  if (isFullscreen) {
    // Hide non-game UI
    document.querySelector('header').style.display = 'none';
    document.querySelector('.container').style.padding = '0';
    document.body.style.background = 'black';

    // Mobile: try to lock orientation
    if (isMobile) {
      const locked = await lockLandscape();
      if (!locked) {
        // Fallback: show rotate prompt if not landscape
        setTimeout(() => {
          if (window.innerWidth < window.innerHeight) {
            showRotatePrompt();
          }
        }, 500);
      }
    }
  } else {
    // Exit fullscreen
    document.querySelector('header').style.display = 'flex';
    document.querySelector('.container').style.padding = '18px';
    document.body.style.background = '';
    hideRotatePrompt();
  }
});

// Tap to dismiss rotate prompt
document.addEventListener('pointerdown', () => {
  if (rotatePrompt.style.display === 'flex') {
    hideRotatePrompt();
  }
});

/* ================= CORE ================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("comboVal");
const missEl = document.getElementById("misses");
const aiEl = document.getElementById("ai");
const comboText = document.getElementById("comboText");

let DPR = Math.max(1, window.devicePixelRatio || 1), W, H;
function resize() {
  W = canvas.offsetWidth; H = canvas.offsetHeight;
  canvas.width = W * DPR; canvas.height = H * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener("resize", resize);
resize();

/* ================= STATE ================= */
let orbs = [];
let score = 0, combo = 0, misses = 0;
let clicks = 0, hits = 0, reactionTimes = [];

/* ================= SKILL INDEX ================= */
function skillIndex() {
  const acc = hits / Math.max(1, clicks);
  const avg = reactionTimes.reduce((a, b) => a + b, 0) / Math.max(1, reactionTimes.length);
  const reactScore = Math.max(0, 1 - avg / 1200);
  return Math.min(1, (acc * 0.6 + reactScore * 0.4));
}

/* ================= ORB TYPES ================= */
const TYPES = [
  { emoji: "ü™®", score: 1, shield: false },
  { emoji: "üíé", score: 3, shield: false },
  { emoji: "üåü", score: 5, shield: false },
  { emoji: "üõ°Ô∏è", score: 8, shield: true }
];

/* ================= SPAWN ================= */
function spawn() {
  if (orbs.length > 18) return;
  const t = TYPES[Math.floor(Math.random() * TYPES.length)];
  const skill = skillIndex();
  const minSpeed = 0.003;
  const maxSpeed = 0.012;
  let speed = minSpeed + skill * 0.007 + Math.random() * 0.003;
  speed = Math.min(speed, maxSpeed);

  orbs.push({
    angle: Math.random() * Math.PI * 2,
    radius: 100 + skill * 80 + Math.random() * 60,
    speed: (Math.random() < 0.5 ? -1 : 1) * speed,
    size: 30,
    emoji: t.emoji,
    score: t.score,
    shield: t.shield,
    shieldHP: t.shield ? 1 : 0,
    spawnTs: performance.now(),
    turnChance: skill * 0.005
  });
}
setInterval(spawn, 800);

/* ================= INPUT ================= */
canvas.addEventListener("pointerdown", e => {
  clicks++;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cx = W / 2, cy = H / 2;

  let hit = null, bestD = 9999;
  for (const o of orbs) {
    const ox = cx + Math.cos(o.angle) * o.radius;
    const oy = cy + Math.sin(o.angle) * o.radius;
    const d = Math.hypot(x - ox, y - oy);
    if (d < o.size && d < bestD) {
      hit = o; bestD = d;
    }
  }

  if (hit) {
    hits++;
    reactionTimes.push(performance.now() - hit.spawnTs);
    if (hit.shield && hit.shieldHP > 0) {
      hit.shieldHP--;
      return;
    }
    orbs = orbs.filter(o => o !== hit);
    score += hit.score;
    combo++;
    scoreEl.textContent = score;
    comboEl.textContent = combo;
    comboText.classList.add("show");
    setTimeout(() => comboText.classList.remove("show"), 300);
  } else {
    combo = 0;
    misses++;
    comboEl.textContent = combo;
    missEl.textContent = misses;
  }
});

/* ================= DRAW ================= */
function loop() {
  ctx.clearRect(0, 0, W, H);
  const cx = W / 2, cy = H / 2;
  const skill = skillIndex();
  aiEl.textContent = `AI Skill Index: ${skill.toFixed(2)}`;

  for (const o of orbs) {
    if (Math.random() < o.turnChance) o.speed *= -1;
    o.angle += o.speed;

    const x = cx + Math.cos(o.angle) * o.radius;
    const y = cy + Math.sin(o.angle) * o.radius;

    if (o.shield && o.shieldHP > 0) {
      ctx.beginPath();
      ctx.strokeStyle = "rgba(106,255,209,.8)";
      ctx.lineWidth = 3;
      ctx.arc(x, y, o.size + 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.font = "30px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(o.emoji, x, y);
  }
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>