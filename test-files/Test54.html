<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PDF Image Editor — Export Fixed + Live Logs</title>
<style>
  :root { --bg:#0f1724; --panel:#0b1220; --accent:#60a5fa; --muted:#94a3b8; }
  body{ margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:#0b1220; color:#e6eef8; padding:18px; }
  h2{ margin:6px 0 14px; font-weight:600; color:var(--accent); }
  .controls-row{ display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  input[type=file]{ background:#071126; padding:8px; border-radius:6px; color:#fff; }
  button{ background:var(--accent); border:none; color:#06223a; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
  #workspace{ display:flex; gap:16px; align-items:flex-start; }
  #pdf-panel{ background:#fff; padding:0; border-radius:8px; overflow:hidden; position:relative; width:720px; height:920px; box-shadow:0 6px 24px rgba(0,0,0,0.6); }
  #pdf-container{ position:relative; width:100%; height:100%; background:#fff; }
  #pdf-canvas{ display:block; width:100%; height:auto; background:#fff; }
  img.editable-image{ position:absolute; cursor:move; border:2px dashed rgba(96,165,250,0.8); box-sizing:border-box; }
  #side{ width:360px; }
  .field{ margin-bottom:8px; color:var(--muted); }
  label{ display:inline-block; margin-right:6px; color:#cfe6ff; font-size:13px; }
  input[type=number]{ width:82px; padding:6px; border-radius:6px; border:1px solid #1f2a3a; background:#071126; color:#dbeafe; }
  #controls { margin-top:8px; }
  #log-window{ margin-top:14px; height:180px; overflow:auto; padding:10px; background:#071428; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:12px; color:#bfe1ff; border:1px solid rgba(255,255,255,0.04); }
  .log-row{ margin-bottom:6px; line-height:1.25; }
  .log-time{ color:#7fb0d9; margin-right:8px; }
  .log-error{ color:#ff8a8a; }
  .log-info{ color:#bfe1ff; }
  .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:6px 10px; border-radius:6px; cursor:pointer; }
  .small { font-size:13px; color:var(--muted); margin-top:6px; }
</style>
</head>
<body>

<h2>PDF Editor — Export Fixed + Live Logs</h2>

<div class="controls-row">
  <input id="pdf-upload" type="file" accept="application/pdf" />
  <input id="image-upload" type="file" accept="image/*" />
  <button id="save-pdf-btn">Save PDF with Image</button>
  <button id="clear-logs" class="btn-ghost">Clear logs</button>
  <div class="small">Tip: Upload PDF first → then image. Drag image to place.</div>
</div>

<div id="workspace">
  <div id="pdf-panel">
    <div id="pdf-container">
      <canvas id="pdf-canvas"></canvas>
    </div>
  </div>

  <div id="side">
    <div id="controls" style="display:none;">
      <div class="field">
        <label>X:</label><input type="number" id="pos-x" value="50"/>
        <label style="margin-left:8px;">Y:</label><input type="number" id="pos-y" value="50"/>
      </div>
      <div class="field">
        <label>Width:</label><input type="number" id="img-width" value="100"/>
        <label style="margin-left:8px;">Height:</label><input type="number" id="img-height" value="100"/>
      </div>
      <div class="field">
        <button id="update-btn">Update Image</button>
        <button id="scale-300" class="btn-ghost">Scale for 300 DPI</button>
      </div>
    </div>

    <div id="log-window" aria-live="polite"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.19.0/pdf-lib.min.js"></script>

<script>
/* ---------- logger ---------- */
const logWindow = document.getElementById('log-window');
function now(){ const d=new Date(); return d.toLocaleTimeString(); }
function log(msg, type='info'){
  const row = document.createElement('div');
  row.className = 'log-row';
  const t = document.createElement('span');
  t.className = 'log-time';
  t.textContent = '['+now()+']';
  const m = document.createElement('span');
  m.className = (type==='error' ? 'log-error' : 'log-info');
  m.textContent = ' ' + msg;
  row.appendChild(t); row.appendChild(m);
  logWindow.appendChild(row);
  logWindow.scrollTop = logWindow.scrollHeight;
  console[type==='error' ? 'error' : 'log'](`[${now()}] ${msg}`);
}
document.getElementById('clear-logs').addEventListener('click', ()=>{ logWindow.innerHTML=''; log('Logs cleared'); });

/* ---------- pdf.js setup ---------- */
const pdfjsLib = window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.worker.min.js';

/* ---------- state ---------- */
let pdfDoc = null;
let originalPdfBytes = null;
let currentPage = 1;
let scale = 1.5;
let uploadedImageFile = null;
let imageElement = null;

/* ---------- DOM ---------- */
const canvas = document.getElementById('pdf-canvas');
const ctx = canvas.getContext('2d');
const pdfContainer = document.getElementById('pdf-container');
const controls = document.getElementById('controls');

document.getElementById('pdf-upload').addEventListener('change', async (e) => {
  try {
    const file = e.target.files[0];
    if (!file) { log('No PDF chosen', 'error'); return; }
    originalPdfBytes = await file.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: originalPdfBytes }).promise;
    log(`PDF loaded: ${file.name} (${Math.round(originalPdfBytes.byteLength/1024)} KB)`);
    currentPage = 1;
    await renderPage(currentPage);
  } catch(err){ log('PDF load error: ' + (err.message || err), 'error'); }
});

/* ---------- render page ---------- */
async function renderPage(pageNum){
  try {
    if (!pdfDoc) throw new Error('No PDF loaded');
    const page = await pdfDoc.getPage(pageNum);
    const viewport = page.getViewport({ scale });
    // Backing pixels
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = viewport.width + 'px';
    canvas.style.height = viewport.height + 'px';
    // Clear existing image overlay (we'll re-add if previously set)
    if (imageElement && !document.body.contains(imageElement)) imageElement = null;
    const renderContext = { canvasContext: ctx, viewport };
    await page.render(renderContext).promise;
    log(`Page ${pageNum} rendered — canvas ${viewport.width}×${viewport.height}px`);
    // Ensure container size matches canvas so absolute coords map correctly
    pdfContainer.style.width = viewport.width + 'px';
    pdfContainer.style.height = viewport.height + 'px';
  } catch(err){ log('Render error: ' + (err.message || err), 'error'); }
}

/* ---------- image upload & overlay ---------- */
document.getElementById('image-upload').addEventListener('change', (e) => {
  try {
    const file = e.target.files[0];
    if (!file) { log('No image chosen', 'error'); return; }
    if (!pdfDoc) { alert('Upload a PDF first.'); log('Tried to upload image before PDF', 'error'); return; }
    uploadedImageFile = file;
    const url = URL.createObjectURL(file);

    // remove existing image overlay if present
    if (imageElement) {
      try { pdfContainer.removeChild(imageElement); } catch(e){}
      try { URL.revokeObjectURL(imageElement.src); } catch(e){}
      imageElement = null;
    }

    imageElement = document.createElement('img');
    imageElement.className = 'editable-image';
    imageElement.src = url;
    imageElement.style.left = '50px';
    imageElement.style.top = '50px';
    imageElement.style.width = '160px';
    imageElement.style.height = '160px';
    pdfContainer.appendChild(imageElement);
    makeDraggable(imageElement);
    controls.style.display = 'block';
    updateControlValues();
    log(`Image loaded: ${file.name} (${file.type || 'unknown'})`);
  } catch(err){ log('Image upload error: ' + (err.message || err), 'error'); }
});

/* draggable */
function makeDraggable(img){
  let dragging=false, startX=0, startY=0, offsetX=0, offsetY=0;
  img.addEventListener('mousedown', (ev) => {
    dragging = true;
    const rect = img.getBoundingClientRect();
    startX = ev.clientX; startY = ev.clientY;
    offsetX = ev.clientX - rect.left;
    offsetY = ev.clientY - rect.top;
    ev.preventDefault();
  });
  window.addEventListener('mousemove', (ev) => {
    if (!dragging) return;
    const contRect = pdfContainer.getBoundingClientRect();
    const left = ev.clientX - contRect.left - offsetX;
    const top  = ev.clientY - contRect.top - offsetY;
    img.style.left = Math.max(0, Math.round(left)) + 'px';
    img.style.top  = Math.max(0, Math.round(top)) + 'px';
    updateControlValues();
  });
  window.addEventListener('mouseup', ()=> dragging=false);
}

/* control inputs */
function updateControlValues(){
  if (!imageElement) return;
  document.getElementById('pos-x').value = parseInt(imageElement.style.left) || 0;
  document.getElementById('pos-y').value = parseInt(imageElement.style.top) || 0;
  document.getElementById('img-width').value = parseInt(imageElement.style.width) || 100;
  document.getElementById('img-height').value = parseInt(imageElement.style.height) || 100;
}
document.getElementById('update-btn').addEventListener('click', () => {
  if (!imageElement) return;
  const x = parseInt(document.getElementById('pos-x').value) || 0;
  const y = parseInt(document.getElementById('pos-y').value) || 0;
  const w = parseInt(document.getElementById('img-width').value) || 100;
  const h = parseInt(document.getElementById('img-height').value) || 100;
  imageElement.style.left = x + 'px';
  imageElement.style.top  = y + 'px';
  imageElement.style.width = w + 'px';
  imageElement.style.height = h + 'px';
  log(`Image moved/resized -> x:${x}, y:${y}, w:${w}, h:${h}`);
});

/* optional scale helper for printing at 300 DPI (best-effort) */
document.getElementById('scale-300').addEventListener('click', () => {
  if (!imageElement) return;
  // rough heuristic: increase pixel size so exported image is dense
  imageElement.style.width = (parseFloat(imageElement.style.width) * 1.8) + 'px';
  imageElement.style.height = (parseFloat(imageElement.style.height) * 1.8) + 'px';
  updateControlValues();
  log('Scaled image visually for higher DPI (approx 300 DPI).');
});

/* ---------- image conversion helpers ---------- */
function dataURLToUint8Array(dataURL){
  const base64 = dataURL.split(',')[1];
  const raw = atob(base64);
  const u8 = new Uint8Array(raw.length);
  for (let i=0;i<raw.length;i++) u8[i] = raw.charCodeAt(i);
  return u8;
}

async function convertFileToPngBytes(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      try {
        // upscale by devicePixelRatio to preserve detail for print
        const r = window.devicePixelRatio || 1;
        const scaleFactor = Math.max(1, r * 2);
        const c = document.createElement('canvas');
        c.width = Math.max(1, Math.round(img.naturalWidth * scaleFactor));
        c.height = Math.max(1, Math.round(img.naturalHeight * scaleFactor));
        const cctx = c.getContext('2d');
        cctx.drawImage(img, 0, 0, c.width, c.height);
        const dataURL = c.toDataURL('image/png');
        try { URL.revokeObjectURL(url); } catch(e){}
        resolve(dataURLToUint8Array(dataURL));
      } catch(err){
        try { URL.revokeObjectURL(url); } catch(e){}
        reject(err);
      }
    };
    img.onerror = (err) => {
      try { URL.revokeObjectURL(url); } catch(e){}
      reject(err || new Error('image load failed'));
    };
    img.src = url;
  });
}

async function getImageBytesReliable(){
  if (uploadedImageFile) {
    const type = (uploadedImageFile.type || '').toLowerCase();
    const ab = await uploadedImageFile.arrayBuffer();
    if (type === 'image/png' || type === 'image/jpeg' || type === 'image/jpg') {
      log('Using original image bytes (no conversion).');
      return { bytes: new Uint8Array(ab), mime: type || 'image/png' };
    } else {
      log('Converting image to PNG for best-quality embed...');
      const pngBytes = await convertFileToPngBytes(uploadedImageFile);
      return { bytes: pngBytes, mime: 'image/png' };
    }
  } else if (imageElement && imageElement.src) {
    if (imageElement.src.startsWith('data:image')) {
      const mime = imageElement.src.match(/^data:(image\/[^;]+);/)?.[1] || 'image/png';
      return { bytes: dataURLToUint8Array(imageElement.src), mime };
    } else {
      log('Fetching image from object URL (fallback).');
      const resp = await fetch(imageElement.src);
      const blob = await resp.blob();
      const mime = blob.type || 'image/png';
      const ab = await blob.arrayBuffer();
      if (mime === 'image/png' || mime === 'image/jpeg' || mime === 'image/jpg') {
        return { bytes: new Uint8Array(ab), mime };
      } else {
        const file = new File([blob], 'temp.img', { type: mime });
        const pngBytes = await convertFileToPngBytes(file);
        return { bytes: pngBytes, mime: 'image/png' };
      }
    }
  } else {
    throw new Error('No usable image source found.');
  }
}

/* ---------- save PDF handler ---------- */
document.getElementById('save-pdf-btn').addEventListener('click', async () => {
  try {
    if (!pdfDoc) { log('Export failed: No PDF uploaded', 'error'); alert('Upload a PDF first'); return; }
    if (!imageElement) { log('Export failed: No image placed', 'error'); alert('Place an image first'); return; }
    if (!originalPdfBytes) throw new Error('Original PDF bytes missing');

    log('Starting export process...');
    const pdfLibDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
    log('pdf-lib loaded original PDF.');

    const pageIndex = currentPage - 1;
    const page = pdfLibDoc.getPage(pageIndex);
    const { width: pageWidth, height: pageHeight } = page.getSize();
    log(`PDF page size: ${Math.round(pageWidth)} × ${Math.round(pageHeight)} (points)`);

    // compute mapping from display -> PDF points
    const canvasRect = canvas.getBoundingClientRect();
    const displayW = canvasRect.width;
    const displayH = canvasRect.height;
    if (!displayW || !displayH) throw new Error('Canvas display dimensions unavailable');

    const imgLeft = parseFloat(imageElement.style.left) || 0;
    const imgTop  = parseFloat(imageElement.style.top)  || 0;
    const imgW    = parseFloat(imageElement.style.width) || 100;
    const imgH    = parseFloat(imageElement.style.height) || 100;

    const x_pdf = (imgLeft / displayW) * pageWidth;
    const width_pdf = (imgW / displayW) * pageWidth;
    const y_pdf = pageHeight - ((imgTop + imgH) / displayH) * pageHeight;
    const height_pdf = (imgH / displayH) * pageHeight;

    log(`Mapped coordinates => x:${x_pdf.toFixed(2)}, y:${y_pdf.toFixed(2)}, w:${width_pdf.toFixed(2)}, h:${height_pdf.toFixed(2)}`);

    // get image bytes reliably and embed
    const { bytes: imgBytes, mime } = await getImageBytesReliable();
    log(`Image bytes ready (mime=${mime}, bytes=${imgBytes.length})`);

    let embedded;
    if (mime === 'image/png') {
      embedded = await pdfLibDoc.embedPng(imgBytes);
      log('Embedded image as PNG.');
    } else if (mime === 'image/jpeg' || mime === 'image/jpg') {
      embedded = await pdfLibDoc.embedJpg(imgBytes);
      log('Embedded image as JPG.');
    } else {
      // fallback — embed PNG
      embedded = await pdfLibDoc.embedPng(imgBytes);
      log('Embedded image with fallback PNG.');
    }

    // draw image
    page.drawImage(embedded, { x: x_pdf, y: y_pdf, width: width_pdf, height: height_pdf });
    log('Image drawn on PDF page.');

    // save bytes, offer for download
    const pdfBytesNew = await pdfLibDoc.save({ useObjectStreams: false });
    log(`PDF saved in-memory (${Math.round(pdfBytesNew.byteLength/1024)} KB). Preparing download...`);

    const blob = new Blob([pdfBytesNew], { type: 'application/pdf' });
    const pdfUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = pdfUrl;
    a.download = 'edited.pdf';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(pdfUrl);
    log('Download triggered — check your Downloads folder.');
    // do not immediately revoke image objectURL; revoke if we created temporary ones earlier
  } catch(err){
    log('Export error: ' + (err.message || err), 'error');
    alert('Export failed — check logs below.');
  }
});
</script>
</body>
</html>