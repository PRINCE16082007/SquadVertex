<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PDF Editor — Fixed detached ArrayBuffer + Logs</title>
<style>
  body{ margin:16px; font-family:Inter,system-ui,Roboto,Arial; background:#071025; color:#e6f3ff; }
  h2{ color:#7cc1ff; }
  .controls{ display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  input[type=file]{ padding:8px; border-radius:6px; background:#071428; color:#fff; border:1px solid rgba(255,255,255,0.03); }
  button{ padding:8px 12px; border-radius:8px; border:none; background:#7cc1ff; color:#032033; font-weight:600; cursor:pointer; }
  #workspace{ display:flex; gap:16px; align-items:flex-start; }
  #pdf-panel{ width:720px; height:920px; background:#fff; border-radius:8px; overflow:hidden; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
  #pdf-container{ position:relative; width:100%; height:100%; background:#fff; }
  #pdf-canvas{ display:block; width:100%; height:auto; background:#fff; }
  img.editable-image{ position:absolute; cursor:move; border:2px dashed rgba(124,193,255,0.9); box-sizing:border-box; }
  #side{ width:360px; }
  .field{ margin-bottom:8px; color:#cde6ff; }
  label{ color:#bfe7ff; margin-right:6px; }
  input[type=number]{ width:80px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:#071428; color:#e6f7ff; }
  #log-window{ margin-top:10px; height:220px; overflow:auto; padding:10px; background:#041422; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:12px; color:#bfe1ff; border:1px solid rgba(255,255,255,0.03); }
  .log-time{ color:#80bde6; margin-right:8px; }
  .log-error{ color:#ff9b9b; }
  .log-info{ color:#cfeeff; }
  .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:#9fc8ea; padding:6px 10px; border-radius:6px; cursor:pointer; }
</style>
</head>
<body>

<h2>PDF Editor — Fixed detached ArrayBuffer + Logs</h2>

<div class="controls">
  <input id="pdf-upload" type="file" accept="application/pdf" />
  <input id="image-upload" type="file" accept="image/*" />
  <button id="save-pdf-btn">Save PDF with Image</button>
  <button id="clear-logs" class="btn-ghost">Clear logs</button>
  <div style="color:#9fc8ea;">Upload PDF first → then image. Drag to place.</div>
</div>

<div id="workspace">
  <div id="pdf-panel">
    <div id="pdf-container">
      <canvas id="pdf-canvas"></canvas>
    </div>
  </div>

  <div id="side">
    <div id="controls" style="display:none;">
      <div class="field">
        <label>X:</label><input type="number" id="pos-x" value="50"/>
        <label style="margin-left:8px;">Y:</label><input type="number" id="pos-y" value="50"/>
      </div>
      <div class="field">
        <label>Width:</label><input type="number" id="img-width" value="160"/>
        <label style="margin-left:8px;">Height:</label><input type="number" id="img-height" value="160"/>
      </div>
      <div class="field">
        <button id="update-btn">Update Image</button>
        <button id="scale-300" class="btn-ghost">Scale for 300 DPI</button>
      </div>
    </div>

    <div id="log-window" aria-live="polite"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.min.js"></script>
<script>
/* -------- logger -------- */
const logWindow = document.getElementById('log-window');
function now(){ return new Date().toLocaleTimeString(); }
function log(msg, type='info'){
  const row = document.createElement('div');
  row.className = 'log-row';
  const t = document.createElement('span');
  t.className = 'log-time';
  t.textContent = '['+now()+']';
  const m = document.createElement('span');
  m.className = (type==='error' ? 'log-error' : 'log-info');
  m.textContent = ' ' + msg;
  row.appendChild(t); row.appendChild(m);
  logWindow.appendChild(row);
  logWindow.scrollTop = logWindow.scrollHeight;
  console[type==='error' ? 'error' : 'log'](`[${now()}] ${msg}`);
}
document.getElementById('clear-logs').addEventListener('click', ()=>{ logWindow.innerHTML=''; log('Logs cleared'); });

/* -------- pdf.js ---------- */
const pdfjsLib = window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.worker.min.js';

/* -------- state -------- */
let pdfDoc = null;
let originalPdfBytes = null;
let currentPage = 1;
let scale = 1.5;
let uploadedImageFile = null;
let imageElement = null;

/* -------- DOM refs -------- */
const canvas = document.getElementById('pdf-canvas');
const ctx = canvas.getContext('2d');
const pdfContainer = document.getElementById('pdf-container');
const controls = document.getElementById('controls');

/* -------- dynamic loader for pdf-lib -------- */
async function loadScript(url, timeout = 12000){
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    let done = false;
    s.src = url;
    s.async = true;
    s.onload = () => { done = true; resolve(s); };
    s.onerror = (e) => { if (!done) { done = true; reject(new Error('Script load failed: ' + url)); } };
    document.head.appendChild(s);
    setTimeout(()=>{ if (!done) reject(new Error('Timeout loading script: ' + url)); }, timeout);
  });
}
let PDFLibReady = false;
async function ensurePDFLib(){
  if (PDFLibReady && window.PDFLib) return window.PDFLib;
  if (window.PDFLib) { PDFLibReady = true; log('PDFLib already present'); return window.PDFLib; }
  const cdns = [
    'https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js',
    'https://unpkg.com/pdf-lib/dist/pdf-lib.min.js'
  ];
  let lastErr = null;
  for (const url of cdns){
    try{
      log('Attempting to load pdf-lib from: ' + url);
      await loadScript(url, 12000);
      if (window.PDFLib) { PDFLibReady = true; log('Loaded pdf-lib from: ' + url); return window.PDFLib; }
    } catch(err){ lastErr = err; log('Failed to load from ' + url + ' — ' + (err.message||err), 'error'); }
  }
  if (window.PDFLib) { PDFLibReady = true; return window.PDFLib; }
  throw new Error('Unable to load pdf-lib library: ' + (lastErr ? lastErr.message : 'unknown'));
}

/* -------- PDF load & render -------- */
document.getElementById('pdf-upload').addEventListener('change', async (e) => {
  try {
    const file = e.target.files[0];
    if (!file) { log('No PDF chosen', 'error'); return; }
    originalPdfBytes = await file.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: originalPdfBytes }).promise;
    log(`PDF loaded: ${file.name} (${Math.max(0, Math.round(originalPdfBytes.byteLength/1024))} KB)`);
    currentPage = 1;
    await renderPage(currentPage);
  } catch(err){ log('PDF load error: ' + (err.message || err), 'error'); }
});

async function renderPage(pageNum){
  try {
    if (!pdfDoc) throw new Error('No PDF loaded');
    const page = await pdfDoc.getPage(pageNum);
    const viewport = page.getViewport({ scale });
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = viewport.width + 'px';
    canvas.style.height = viewport.height + 'px';
    const renderContext = { canvasContext: ctx, viewport };
    await page.render(renderContext).promise;
    log(`Page ${pageNum} rendered — canvas ${viewport.width}×${viewport.height}px`);
    pdfContainer.style.width = viewport.width + 'px';
    pdfContainer.style.height = viewport.height + 'px';
  } catch(err){ log('Render error: ' + (err.message || err), 'error'); }
}

/* -------- image overlay handling -------- */
document.getElementById('image-upload').addEventListener('change', (e) => {
  try {
    const file = e.target.files[0];
    if (!file) { log('No image chosen', 'error'); return; }
    if (!pdfDoc) { alert('Upload a PDF first.'); log('Tried to upload image before PDF', 'error'); return; }
    uploadedImageFile = file;
    const url = URL.createObjectURL(file);
    if (imageElement) { try { pdfContainer.removeChild(imageElement); } catch(e){} try { URL.revokeObjectURL(imageElement.src);}catch(e){} imageElement = null; }
    imageElement = document.createElement('img');
    imageElement.className = 'editable-image';
    imageElement.src = url;
    imageElement.style.left = '50px';
    imageElement.style.top = '50px';
    imageElement.style.width = '160px';
    imageElement.style.height = '160px';
    pdfContainer.appendChild(imageElement);
    makeDraggable(imageElement);
    controls.style.display = 'block';
    updateControlValues();
    log(`Image loaded: ${file.name} (${file.type || 'unknown'})`);
  } catch(err){ log('Image upload error: ' + (err.message || err), 'error'); }
});

function makeDraggable(img){
  let dragging=false, offsetX=0, offsetY=0;
  img.addEventListener('mousedown', (ev) => {
    dragging = true;
    const rect = img.getBoundingClientRect();
    offsetX = ev.clientX - rect.left;
    offsetY = ev.clientY - rect.top;
    ev.preventDefault();
  });
  window.addEventListener('mousemove', (ev) => {
    if (!dragging) return;
    const contRect = pdfContainer.getBoundingClientRect();
    const left = ev.clientX - contRect.left - offsetX;
    const top  = ev.clientY - contRect.top - offsetY;
    img.style.left = Math.max(0, Math.round(left)) + 'px';
    img.style.top  = Math.max(0, Math.round(top)) + 'px';
    updateControlValues();
  });
  window.addEventListener('mouseup', ()=> dragging=false);
}

function updateControlValues(){
  if (!imageElement) return;
  document.getElementById('pos-x').value = parseInt(imageElement.style.left) || 0;
  document.getElementById('pos-y').value = parseInt(imageElement.style.top) || 0;
  document.getElementById('img-width').value = parseInt(imageElement.style.width) || 100;
  document.getElementById('img-height').value = parseInt(imageElement.style.height) || 100;
}
document.getElementById('update-btn').addEventListener('click', () => {
  if (!imageElement) return;
  const x = parseInt(document.getElementById('pos-x').value) || 0;
  const y = parseInt(document.getElementById('pos-y').value) || 0;
  const w = parseInt(document.getElementById('img-width').value) || 100;
  const h = parseInt(document.getElementById('img-height').value) || 100;
  imageElement.style.left = x + 'px';
  imageElement.style.top  = y + 'px';
  imageElement.style.width = w + 'px';
  imageElement.style.height = h + 'px';
  log(`Image moved/resized -> x:${x}, y:${y}, w:${w}, h:${h}`);
});
document.getElementById('scale-300').addEventListener('click', () => {
  if (!imageElement) return;
  imageElement.style.width = (parseFloat(imageElement.style.width) * 1.8) + 'px';
  imageElement.style.height = (parseFloat(imageElement.style.height) * 1.8) + 'px';
  updateControlValues();
  log('Scaled image visually for higher DPI (approx 300 DPI).');
});

/* -------- image conversion helpers -------- */
function dataURLToUint8Array(dataURL){
  const base64 = dataURL.split(',')[1];
  const raw = atob(base64);
  const u8 = new Uint8Array(raw.length);
  for (let i=0;i<raw.length;i++) u8[i] = raw.charCodeAt(i);
  return u8;
}
async function convertFileToPngBytes(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      try {
        const r = window.devicePixelRatio || 1;
        const scaleFactor = Math.max(1, r * 2);
        const c = document.createElement('canvas');
        c.width = Math.max(1, Math.round(img.naturalWidth * scaleFactor));
        c.height = Math.max(1, Math.round(img.naturalHeight * scaleFactor));
        const cctx = c.getContext('2d');
        cctx.drawImage(img, 0, 0, c.width, c.height);
        const dataURL = c.toDataURL('image/png');
        try { URL.revokeObjectURL(url); } catch(e){}
        resolve(dataURLToUint8Array(dataURL));
      } catch(err){
        try { URL.revokeObjectURL(url); } catch(e){}
        reject(err);
      }
    };
    img.onerror = (err) => { try { URL.revokeObjectURL(url); } catch(e){} reject(err || new Error('image load failed')); };
    img.src = url;
  });
}

/* make a safe copy of any ArrayBuffer-like input */
function ensureFreshUint8Array(input){
  // input may be ArrayBuffer, Uint8Array, or ArrayBuffer view
  if (input instanceof Uint8Array) {
    return input.slice(0); // returns a fresh copy
  } else if (input instanceof ArrayBuffer) {
    return new Uint8Array(input.slice(0));
  } else if (ArrayBuffer.isView(input) && input.buffer) {
    // like DataView or TypedArray
    return new Uint8Array(input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength));
  } else {
    // fallback: try to coerce
    return new Uint8Array(input);
  }
}

async function getImageBytesReliable(){
  if (uploadedImageFile) {
    const type = (uploadedImageFile.type || '').toLowerCase();
    const ab = await uploadedImageFile.arrayBuffer();
    if (type === 'image/png' || type === 'image/jpeg' || type === 'image/jpg') {
      log('Using original image bytes (no conversion).');
      return { bytes: ensureFreshUint8Array(new Uint8Array(ab)), mime: type || 'image/png' };
    } else {
      log('Converting image to PNG for best-quality embed...');
      const pngBytes = await convertFileToPngBytes(uploadedImageFile);
      return { bytes: ensureFreshUint8Array(pngBytes), mime: 'image/png' };
    }
  } else if (imageElement && imageElement.src) {
    if (imageElement.src.startsWith('data:image')) {
      const mime = imageElement.src.match(/^data:(image\/[^;]+);/)?.[1] || 'image/png';
      return { bytes: ensureFreshUint8Array(dataURLToUint8Array(imageElement.src)), mime };
    } else {
      log('Fetching image from object URL (fallback).');
      const resp = await fetch(imageElement.src);
      const blob = await resp.blob();
      const mime = blob.type || 'image/png';
      const ab = await blob.arrayBuffer();
      if (mime === 'image/png' || mime === 'image/jpeg' || mime === 'image/jpg') {
        return { bytes: ensureFreshUint8Array(new Uint8Array(ab)), mime };
      } else {
        const file = new File([blob], 'temp.img', { type: mime });
        const pngBytes = await convertFileToPngBytes(file);
        return { bytes: ensureFreshUint8Array(pngBytes), mime: 'image/png' };
      }
    }
  } else {
    throw new Error('No usable image source found.');
  }
}

/* -------- save/export handler (waits for pdf-lib) -------- */
async function robustEmbedAndSave(PDFLib, originalBytes, imageBytes, mime, coords){
  // Make fresh copies of both PDF bytes and image bytes to avoid any detached buffer problems
  const pdfBytesCopy = (originalBytes instanceof ArrayBuffer) ? originalBytes.slice(0) : originalBytes;
  const imageBytesSafe = ensureFreshUint8Array(imageBytes);

  const pdfLibDoc = await PDFLib.PDFDocument.load(pdfBytesCopy);
  log('pdf-lib loaded original PDF (safe copy).');

  const page = pdfLibDoc.getPage(coords.pageIndex);
  const { width: pageWidth, height: pageHeight } = page.getSize();
  log(`PDF page size inside save: ${Math.round(pageWidth)}×${Math.round(pageHeight)} pts`);

  let embedded;
  try {
    if (mime === 'image/png') {
      embedded = await pdfLibDoc.embedPng(imageBytesSafe);
      log('Embedded PNG (safe copy).');
    } else if (mime === 'image/jpeg' || mime === 'image/jpg') {
      embedded = await pdfLibDoc.embedJpg(imageBytesSafe);
      log('Embedded JPG (safe copy).');
    } else {
      embedded = await pdfLibDoc.embedPng(imageBytesSafe);
      log('Embedded fallback PNG (safe copy).');
    }
  } catch (err) {
    // If embed fails, log detailed info and rethrow
    log('Embed failure — bytes length: ' + (imageBytesSafe ? imageBytesSafe.length : 'unknown'), 'error');
    log('Embed stack: ' + (err && err.message ? err.message : err), 'error');
    throw err;
  }

  page.drawImage(embedded, { x: coords.x, y: coords.y, width: coords.width, height: coords.height });
  log('Image drawn on PDF page (inside robustEmbedAndSave).');

  const outBytes = await pdfLibDoc.save({ useObjectStreams: false });
  return outBytes;
}

document.getElementById('save-pdf-btn').addEventListener('click', async () => {
  try {
    if (!pdfDoc) { log('Export failed: No PDF uploaded', 'error'); alert('Upload a PDF first'); return; }
    if (!imageElement) { log('Export failed: No image placed', 'error'); alert('Place an image first'); return; }
    if (!originalPdfBytes) throw new Error('Original PDF bytes missing');

    log('Starting export process... (ensuring pdf-lib is loaded)');
    const PDFLib = await ensurePDFLib();
    if (!PDFLib) throw new Error('pdf-lib did not initialize');
    log('pdf-lib ready.');

    // compute mapping from display -> PDF points
    const pageIndex = currentPage - 1;
    const canvasRect = canvas.getBoundingClientRect();
    const displayW = canvasRect.width, displayH = canvasRect.height;
    if (!displayW || !displayH) throw new Error('Canvas display dimensions unavailable');

    const imgLeft = parseFloat(imageElement.style.left) || 0;
    const imgTop  = parseFloat(imageElement.style.top)  || 0;
    const imgW    = parseFloat(imageElement.style.width) || 100;
    const imgH    = parseFloat(imageElement.style.height) || 100;

    // load a lightweight page with pdf-lib just to compute page size (we will reload safely inside robust function)
    const pdfTempDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
    const tempPage = pdfTempDoc.getPage(pageIndex);
    const { width: pageWidth, height: pageHeight } = tempPage.getSize();
    log(`PDF page size (pre-check): ${Math.round(pageWidth)} × ${Math.round(pageHeight)} pts`);

    const x_pdf = (imgLeft / displayW) * pageWidth;
    const width_pdf = (imgW / displayW) * pageWidth;
    const y_pdf = pageHeight - ((imgTop + imgH) / displayH) * pageHeight;
    const height_pdf = (imgH / displayH) * pageHeight;
    log(`Mapped coords => x:${x_pdf.toFixed(2)}, y:${y_pdf.toFixed(2)}, w:${width_pdf.toFixed(2)}, h:${height_pdf.toFixed(2)}`);

    // prepare image bytes (fresh copy)
    const { bytes: imgBytes, mime } = await getImageBytesReliable();
    log(`Image bytes prepared (mime=${mime}, bytes=${imgBytes.length})`);

    // call robust embed/save which clones buffers and embeds
    const coords = { pageIndex, x: x_pdf, y: y_pdf, width: width_pdf, height: height_pdf };
    const outBytes = await robustEmbedAndSave(PDFLib, originalPdfBytes, imgBytes, mime, coords);

    log(`PDF saved in-memory (${Math.round(outBytes.byteLength/1024)} KB). Preparing download...`);
    const blob = new Blob([outBytes], { type: 'application/pdf' });
    const pdfUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = pdfUrl;
    a.download = 'edited.pdf';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(pdfUrl);
    log('Download triggered — check your Downloads folder.');
  } catch(err){
    log('Export error: ' + (err && err.message ? err.message : err), 'error');
    console.error(err);
    alert('Export failed — check logs for details.');
  }
});
</script>
</body>
</html>