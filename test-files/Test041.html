<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>About Team Galaxy â€” Orbit Playground (Realistic)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Poppins:wght@300;500&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#08101b;
      --panel: rgba(12,18,26,0.6);
      --accent: #64c2ff;
      --muted: #9fcff6;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018 0%, #051028 60%);color:#eaf7ff;font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial;smooth-font-smoothing:antialiased}
    .top-bar{height:72px;display:flex;align-items:center;justify-content:space-between;padding:0 18px;background:rgba(6,14,22,0.6);backdrop-filter: blur(6px);position:sticky;top:0;z-index:40;border-bottom:1px solid rgba(255,255,255,0.03)}
    .logo{display:flex;align-items:center;gap:12px;font-weight:700;font-family:'Montserrat',sans-serif;color:#fff;cursor:pointer}
    .logo img{height:42px;filter:drop-shadow(0 6px 18px rgba(36,160,255,0.08))}
    .nav {display:flex;gap:12px;align-items:center}
    .nav button{background:transparent;border:0;color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
    .nav button:hover{color:var(--accent);background:rgba(100,194,255,0.06)}

    /* HERO PLAYGROUND */
    .hero-wrap {position:relative;height:420px;margin:18px auto 32px;max-width:1200px;padding:18px;box-sizing:border-box}
    .playground-card {position:relative;height:100%;border-radius:14px;overflow:hidden;background:linear-gradient(180deg, rgba(6,12,20,0.45), rgba(3,6,12,0.55));box-shadow:0 18px 60px rgba(5,10,20,0.7), inset 0 -40px 80px rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.03)}
    /* canvas stack */
    .pg-canvas {position:absolute;inset:0;display:block;touch-action:none}
    /* centerplanet is DOM to keep crisp UI and focus ring for accessibility */
    .orbit-center {position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:140px;height:140px;border-radius:50%;z-index:18;display:flex;align-items:center;justify-content:center}
    .planet {width:100%;height:100%;border-radius:50%;
      background: radial-gradient(circle at 25% 25%, #ffd9a8 0%, #ffb86b 22%, #ef6c49 52%, #b33a2e 82%);
      box-shadow: 0 18px 48px rgba(255,160,90,0.08), 0 6px 20px rgba(0,0,0,0.5), inset -14px -8px 36px rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.04);filter:drop-shadow(0 14px 36px rgba(255,140,60,0.06));
      position:relative;overflow:hidden
    }
    .planet::after{content:'';position:absolute;inset:0;border-radius:50%;
      background: radial-gradient(circle at 15% 12%, rgba(255,255,255,0.12), rgba(255,255,255,0.02) 8%, transparent 24%);
      mix-blend-mode:screen;opacity:0.95;pointer-events:none;
    }
    .ring {position:absolute;width:260px;height:260px;border-radius:50%;left:50%;top:50%;transform:translate(-50%,-50%) rotateX(70deg) rotateZ(10deg);z-index:12;pointer-events:none;filter:blur(6px);opacity:0.65}
    /* HUD */
    .hud {position:absolute;right:18px;top:14px;z-index:32;background:linear-gradient(180deg, rgba(8,14,20,0.52), rgba(6,10,16,0.52));padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);display:flex;gap:10px;align-items:center;backdrop-filter:blur(6px)}
    .hud .btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;color:var(--muted);cursor:pointer;font-weight:600}
    .hud .btn:hover{background:rgba(100,194,255,0.08);color:#fff}
    .score {font-weight:700;color:#dff8ff}
    .small-muted{font-size:0.85rem;color:#9fc7e6;opacity:0.9}

    /* controls row */
    .controls {display:flex;gap:10px;align-items:center}
    .toggle {display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-weight:600;color:#dbefff;cursor:pointer}
    .toggle input{width:18px;height:18px}

    /* small responsive */
    @media (max-width:860px){.hero-wrap{height:360px}.orbit-center{width:112px;height:112px}.planet{border-width:1px}}
    /* rest minimal so page works with original content */
    main{max-width:1100px;margin:0 auto;padding:8px}
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="logo" onclick="location.href='dashboard.html'">
      <img src="https://dl.dropboxusercontent.com/scl/fi/ulfs6ygkeyvr4mar8bkuz/galaxwbewh.png?rlkey=jq9buj80ny6et6jfbfpiuf14l&st=lwkqobqi&dl=0" alt="logo">
      Team Galaxy
    </div>
    <div class="nav">
      <button onclick="location.href='posts.html'">Posts</button>
      <button onclick="location.href='community_chat.html'">Community</button>
      <button onclick="location.href='about_us.html'">About</button>
    </div>
  </div>

  <!-- HERO: Orbit Playground -->
  <div class="hero-wrap" aria-hidden="false">
    <div class="playground-card" role="region" aria-label="Orbit playground: spawn and collect satellites">
      <!-- layers of canvas: trails -> main -> particles -->
      <canvas id="trailsCanvas" class="pg-canvas" aria-hidden="true"></canvas>
      <canvas id="mainCanvas" class="pg-canvas" aria-hidden="true"></canvas>
      <canvas id="fxCanvas" class="pg-canvas" aria-hidden="true"></canvas>

      <!-- 3D ring visual (DOM) -->
      <div class="ring" aria-hidden="true">
        <svg viewBox="0 0 200 200" width="100%" height="100%">
          <defs>
            <linearGradient id="ringGrad" x1="0" x2="1">
              <stop offset="0" stop-color="#64c2ff" stop-opacity="0.06"/>
              <stop offset="0.5" stop-color="#a6f0ff" stop-opacity="0.06"/>
              <stop offset="1" stop-color="#64c2ff" stop-opacity="0.02"/>
            </linearGradient>
          </defs>
          <ellipse cx="100" cy="100" rx="86" ry="40" fill="none" stroke="url(#ringGrad)" stroke-width="3"/>
        </svg>
      </div>

      <!-- planet DOM (center) -->
      <div class="orbit-center" role="img" aria-label="Planet">
        <div class="planet" id="planet" tabindex="0" title="Our planet - spawn orbiters around me by clicking"></div>
      </div>

      <!-- HUD -->
      <div class="hud" role="status" aria-live="polite">
        <div>
          <div class="score" id="collected">Collected: 0</div>
          <div class="small-muted" id="highscore">High: 0</div>
        </div>
        <div style="width:10px"></div>
        <div class="controls">
          <button class="btn" id="btnSpawn">Spawn</button>
          <button class="btn" id="btnClear">Clear</button>
          <button class="btn" id="btnAuto">Auto: Off</button>
        </div>
      </div>
    </div>
  </div>

  <main>
    <!-- keep your about content below unchanged; placeholder shortened for brevity -->
    <h1 style="color:#fab84f;margin-top:8px">About Team Galaxy</h1>
    <section style="background:rgba(10,14,20,0.6);padding:18px;border-radius:12px;margin-top:12px">
      <h2 style="color:#fff">What is Team Galaxy?</h2>
      <p style="color:#cfefff">Team Galaxy shines on the competitive stage... (content kept as before)</p>
    </section>
  </main>

  <!-- JS: playground (no external libs, all localStorage, WebAudio, performant) -->
  <script>
  (function(){
    /* ---------- CONFIG & STATE ---------- */
    const MAX_ORBS = 32;
    const TRAIL_FADE = 0.12; // 0..1, bigger -> faster fade
    const ORB_RARITY = [
      {label:'common', chance:0.78, size:9, color:'#7BE0FF', score:1},
      {label:'uncommon', chance:0.16, size:12, color:'#FFD57B', score:3},
      {label:'rare', chance:0.05, size:16, color:'#D6FF9A', score:6},
      {label:'epic', chance:0.01, size:20, color:'#FF9AD6', score:12}
    ];

    const trailsCanvas = document.getElementById('trailsCanvas');
    const mainCanvas = document.getElementById('mainCanvas');
    const fxCanvas = document.getElementById('fxCanvas');
    const canvases = [trailsCanvas, mainCanvas, fxCanvas];
    const ctxTrails = trailsCanvas.getContext('2d', { alpha: true });
    const ctx = mainCanvas.getContext('2d', { alpha: true });
    const ctxFx = fxCanvas.getContext('2d', { alpha: true });

    const container = document.querySelector('.playground-card');
    let W = container.clientWidth, H = container.clientHeight;
    canvases.forEach(c => { c.width = W; c.height = H; c.style.width = '100%'; c.style.height = '100%'; });

    const planetEl = document.getElementById('planet');
    const collectedEl = document.getElementById('collected');
    const highscoreEl = document.getElementById('highscore');
    const btnSpawn = document.getElementById('btnSpawn');
    const btnClear = document.getElementById('btnClear');
    const btnAuto = document.getElementById('btnAuto');

    // center point (relative to canvas)
    function center(){ return { x: W/2, y: H/2 }; }

    // localStorage keys
    const LS_COL = 'galaxy_collected_v2';
    const LS_HIGH = 'galaxy_high_v2';
    const LS_AUTO = 'galaxy_auto_v2';

    let collected = parseInt(localStorage.getItem(LS_COL)) || 0;
    let high = parseInt(localStorage.getItem(LS_HIGH)) || 0;
    let autoMode = localStorage.getItem(LS_AUTO) === '1';

    // orbs & particles
    let orbs = []; // {id, angle, radius, speed, size, color, rarity, thetaOffset}
    let pops = []; // particles for fx
    let lastTime = performance.now();
    let running = true;
    let nextId = 1;

    // audio
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx) audioCtx = new AudioCtx();
    }
    function playCollectTone(freq=420, dur=0.08){
      try{
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = freq;
        g.gain.value = 0;
        o.connect(g); g.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        g.gain.linearRampToValueAtTime(0.12, now + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
        o.start(now);
        o.stop(now + dur + 0.02);
      }catch(e){}
    }
    function playSpawnTick(){ playCollectTone(240,0.06); }

    /* ---------- UTIL ---------- */
    function rand(a,b){ return a + Math.random()*(b-a); }
    function chooseRarity(){
      const r = Math.random();
      let sum = 0;
      for (const rDef of ORB_RARITY){ sum += rDef.chance; if (r <= sum) return rDef; }
      return ORB_RARITY[0];
    }

    /* ---------- RESIZE ---------- */
    function resize(){
      W = container.clientWidth; H = container.clientHeight;
      canvases.forEach(c => { c.width = W; c.height = H; });
      // clear trails on resize to avoid streak artifacts
      ctxTrails.clearRect(0,0,W,H);
    }
    window.addEventListener('resize', resize);

    /* ---------- ORBITAL LOGIC ---------- */
    function spawnOrbAt(x,y){
      if (orbs.length >= MAX_ORBS) return;
      const cen = container.getBoundingClientRect();
      const cx = cen.left + cen.width/2;
      const cy = cen.top + cen.height/2;
      // compute initial radius & angle relative to center
      const dx = (x - cx);
      const dy = (y - cy);
      let r = Math.hypot(dx,dy);
      // clamp radius so it orbits outside the planet
      const minR = Math.max(90, Math.min(cen.width, cen.height)/6);
      const maxR = Math.min(cen.width, cen.height)/2 - 24;
      r = Math.max(minR, Math.min(maxR, r));
      const angle = Math.atan2(dy,dx);
      // compute angular speed - smaller radius -> faster; add variance
      const base = 0.7 / Math.sqrt(Math.max(1,r/80));
      const speed = base * (Math.random() < 0.5 ? 1 : -1) * (0.6 + Math.random()*0.9);
      const rarity = chooseRarity();
      const orb = {
        id: nextId++,
        angle,
        radius: r,
        speed,
        size: rarity.size * (0.85 + Math.random()*0.3),
        color: rarity.color,
        score: rarity.score,
        rarity: rarity.label,
        wobble: Math.random()*0.5,
        birth: performance.now()
      };
      orbs.push(orb);
      playSpawnTick();
      return orb;
    }

    // convenience: spawn a burst near center
    function burst(n=3){
      const rect = container.getBoundingClientRect();
      for (let i=0;i<n;i++){
        const rx = rect.left + rect.width/2 + rand(-120,120);
        const ry = rect.top + rect.height/2 + rand(-60,60);
        spawnOrbAt(rx,ry);
      }
    }

    /* ---------- DRAW ---------- */
    function drawPlanet(ctx){
      const c = center();
      const planetR = 56;
      // subtle inner glow
      const g = ctx.createRadialGradient(c.x-18,c.y-18,planetR*0.12,c.x,c.y,planetR*1.3);
      g.addColorStop(0,'rgba(255,220,170,0.35)');
      g.addColorStop(0.35,'rgba(240,150,90,0.12)');
      g.addColorStop(1,'rgba(6,12,18,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(c.x,c.y,planetR*1.6,0,Math.PI*2); ctx.fill();

      // simple subtle lens flare stripes via globalCompositeOperation lighter
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for (let i=0;i<6;i++){
        ctx.beginPath();
        ctx.ellipse(c.x + Math.sin(i+performance.now()/2600)*8, c.y + Math.cos(i+performance.now()/2600)*6, 82 + i*4, 28 + i*2, 0, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalCompositeOperation = 'source-over';
    }

    // draw orbs onto main canvas with glow
    function drawOrbs(now){
      ctx.clearRect(0,0,W,H);

      const c = center();
      for (const o of orbs){
        // update angle
        o.angle += o.speed * (now.delta * 0.001);
        // slight radius breathing
        const wob = Math.sin((now.t / 800) + o.wobble) * 2.2;
        const x = c.x + (o.radius + wob) * Math.cos(o.angle);
        const y = c.y + (o.radius + wob) * Math.sin(o.angle);

        // draw glow (radial gradient)
        const g = ctx.createRadialGradient(x, y, 0, x, y, o.size*3.8);
        g.addColorStop(0, hexToRgba(o.color, 0.92));
        g.addColorStop(0.25, hexToRgba(o.color, 0.48));
        g.addColorStop(1, hexToRgba(o.color, 0.0));
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(x,y,o.size*1.7,0,Math.PI*2); ctx.fill();

        // core
        ctx.fillStyle = o.color;
        ctx.beginPath(); ctx.arc(x,y,o.size*0.9,0,Math.PI*2); ctx.fill();

        // small highlight
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.arc(x - o.size*0.3, y - o.size*0.3, Math.max(1.6, o.size*0.22), 0, Math.PI*2); ctx.fill();

        // write a faint ring for rare ones
        if (o.rarity === 'rare' || o.rarity === 'epic'){
          ctx.strokeStyle = hexToRgba('#ffffff', 0.06);
          ctx.lineWidth = 1.4;
          ctx.beginPath(); ctx.arc(x,y, o.size*1.9,0,Math.PI*2); ctx.stroke();
        }

        // trails: stamp a faint point into trails canvas to create motion trails
        ctxTrails.fillStyle = hexToRgba(o.color, 0.06);
        ctxTrails.beginPath(); ctxTrails.ellipse(x,y,o.size*1.8,o.size*0.7,0,0,Math.PI*2); ctxTrails.fill();

        // store screen pos for hit detection
        o.screenX = x; o.screenY = y;
      }

      // draw planet effect last (so orbs appear in front), slightly behind center
      drawPlanet(ctx);
    }

    // fx canvas = particle pops
    function updateFX(now){
      ctxFx.clearRect(0,0,W,H);
      for (let i = pops.length - 1; i >= 0; i--){
        const p = pops[i];
        p.life -= now.delta * 0.001;
        if (p.life <= 0){ pops.splice(i,1); continue; }
        // draw radial burst with fade
        const alpha = Math.max(0, p.life/ p.maxLife);
        for (let j=0;j<p.particles.length;j++){
          const pr = p.particles[j];
          const px = p.x + pr.vx * (1 - alpha) * p.speed;
          const py = p.y + pr.vy * (1 - alpha) * p.speed;
          const size = Math.max(0.6, pr.size * alpha);
          const col = pr.color;
          ctxFx.fillStyle = `rgba(${col.r},${col.g},${col.b},${0.85 * alpha})`;
          ctxFx.beginPath(); ctxFx.ellipse(px,py,size,size,0,0,Math.PI*2); ctxFx.fill();
        }
      }
    }

    // clear trails slowly (fade out)
    function fadeTrails(){
      ctxTrails.fillStyle = `rgba(6,8,10,${TRAIL_FADE})`;
      ctxTrails.fillRect(0,0,W,H);
    }

    /* ---------- INTERACTION ---------- */
    function distance(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }

    function hitTest(x,y){
      // returns orb or null; use larger hit radius for easier tapping
      let best = null; let bestD = Infinity;
      for (const o of orbs){
        const d = distance(x,y,o.screenX,o.screenY);
        const hitR = Math.max(18, o.size*1.8);
        if (d <= hitR && d < bestD){ best = o; bestD = d; }
      }
      return best;
    }

    function collectOrb(orb){
      if(!orb) return;
      // spawn pop particles at orb.screenX, orb.screenY
      const x = orb.screenX, y = orb.screenY;
      spawnPop(x,y, orb.color, orb.size);
      // award score
      collected += orb.score;
      if (collected > high) { high = collected; localStorage.setItem(LS_HIGH, high); highscoreEl.textContent = 'High: ' + high; flashHighscore(); }
      localStorage.setItem(LS_COL, collected);
      collectedEl.textContent = 'Collected: ' + collected;
      playCollectTone(380 + orb.score*40, 0.12);
      // remove orb
      orbs = orbs.filter(o => o.id !== orb.id);
    }

    function spawnPop(x,y,colorStr,size){
      const color = parseHex(colorStr);
      const partCount = Math.min(24, Math.round(8 + size*1.2));
      const pop = { x, y, particles:[], life:1.0, maxLife:1.0, speed: 42 + size*6 };
      for (let i=0;i<partCount;i++){
        const ang = Math.random()*Math.PI*2;
        const spd = 0.6 + Math.random()*1.8;
        pop.particles.push({
          vx: Math.cos(ang)*spd*(0.6+Math.random()*2.2),
          vy: Math.sin(ang)*spd*(0.6+Math.random()*2.2),
          size: Math.random()* (size*0.6) + 0.6,
          color
        });
      }
      pops.push(pop);
    }

    /* ---------- EVENTS ---------- */
    function onPointerDown(e){
      e.preventDefault();
      const rect = mainCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // predictive: if you tap near an orb but moved since last frame, we still check both positions
      const orb = hitTest(x,y);
      if (orb){ collectOrb(orb); return; }

      // else spawn near pointer
      spawnOrbAt(e.clientX, e.clientY);
    }

    // support touch + mouse
    mainCanvas.addEventListener('pointerdown', onPointerDown, {passive:false});
    fxCanvas.addEventListener('pointerdown', onPointerDown, {passive:false});
    trailsCanvas.addEventListener('pointerdown', onPointerDown, {passive:false});

    // keyboard spawn (Space)
    window.addEventListener('keydown', (ev) => {
      if (ev.code === 'Space'){ ev.preventDefault(); const rect = mainCanvas.getBoundingClientRect(); spawnOrbAt(rect.left + rect.width/2 + rand(-80,80), rect.top + rect.height/2 + rand(-40,40)); }
    });

    btnSpawn.addEventListener('click', () => burst(3));
    btnClear.addEventListener('click', () => { orbs = []; ctx.clearRect(0,0,W,H); ctxTrails.clearRect(0,0,W,H); });
    btnAuto.addEventListener('click', () => { autoMode = !autoMode; localStorage.setItem(LS_AUTO, autoMode ? '1' : '0'); btnAuto.textContent = 'Auto: ' + (autoMode? 'On':'Off') });

    /* ---------- AUTO SPAWN ---------- */
    let autoTimer = 0;
    function autoTick(now){
      if (!autoMode) return;
      if (orbs.length < 8 && Math.random() < 0.6) burst(1);
      if (Math.random() < 0.18) spawnOrbAt(container.getBoundingClientRect().left + container.clientWidth/2 + rand(-200,200), container.getBoundingClientRect().top + container.clientHeight/2 + rand(-120,120));
    }

    /* ---------- HELPERS ---------- */
    function hexToRgba(hex, a){
      const p = parseHex(hex);
      return `rgba(${p.r},${p.g},${p.b},${a})`;
    }
    function parseHex(hex){
      const s = hex.replace('#','');
      let r,g,b;
      if (s.length === 6){ r = parseInt(s.slice(0,2),16); g = parseInt(s.slice(2,4),16); b = parseInt(s.slice(4,6),16); }
      else { r=255;g=255;b=255; }
      return {r,g,b};
    }

    /* ---------- ANIMATION LOOP ---------- */
    function loop(nowTs){
      if (!running) return;
      const now = { t: nowTs, delta: nowTs - lastTime };
      lastTime = nowTs;

      // fade trails first (draw translucent rect)
      fadeTrails();

      // update orbs, draw main (orbs + planet)
      drawOrbs(now);

      // update fx
      updateFX(now);

      // occasional auto spawn
      autoTimer += now.delta;
      if (autoTimer > 1600){ autoTimer = 0; autoTick(now); }

      requestAnimationFrame(loop);
    }

    /* ---------- UI INIT ---------- */
    function initUI(){
      collectedEl.textContent = 'Collected: ' + collected;
      highscoreEl.textContent = 'High: ' + high;
      btnAuto.textContent = 'Auto: ' + (autoMode? 'On':'Off');
    }

    /* ---------- POPULATE SOME ORBS FOR VISUAL ---------- */
    function warmup(){
      const rect = container.getBoundingClientRect();
      for (let i=0;i<8;i++){
        const x = rect.left + rect.width/2 + rand(-140,140);
        const y = rect.top + rect.height/2 + rand(-90,90);
        spawnOrbAt(x,y);
      }
    }

    /* ---------- HIGH SCORE VISUAL ---------- */
    function flashHighscore(){
      highscoreEl.style.transition = 'transform .25s ease, color .25s ease';
      highscoreEl.style.transform = 'scale(1.08)';
      highscoreEl.style.color = '#fff';
      setTimeout(()=>{ highscoreEl.style.transform = ''; highscoreEl.style.color = ''; }, 420);
    }

    /* ---------- START ---------- */
    resize();
    initUI();
    warmup();
    lastTime = performance.now();
    requestAnimationFrame(loop);

    // periodic trail clear to avoid runaway
    setInterval(() => {
      // small dimming to keep trails but not infinite
      ctxTrails.globalCompositeOperation = 'destination-out';
      ctxTrails.fillStyle = `rgba(6,8,10,${TRAIL_FADE * 0.9})`;
      ctxTrails.fillRect(0,0,W,H);
      ctxTrails.globalCompositeOperation = 'source-over';
    }, 2500);

    // accessibility: focus planet with keyboard explains controls
    planetEl.addEventListener('focus', ()=> {
      planetEl.setAttribute('aria-label','Planet. Click or press Space to spawn satellites. Click a satellite to collect it.');
    });

    // save collected periodically
    setInterval(()=> localStorage.setItem(LS_COL, collected), 2500);

    // graceful stop on page hide
    document.addEventListener('visibilitychange', ()=> { if (document.hidden) running = false; else { running = true; lastTime = performance.now(); requestAnimationFrame(loop); } });

    // small hint: resume audio context on first interaction for mobile
    document.addEventListener('pointerdown', () => { if (!audioCtx) try{ ensureAudio(); }catch(e){} }, { once: true });
  })();
  </script>
</body>
</html>