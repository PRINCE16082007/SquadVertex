<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GitHub Repo Analyzer ‚Äî SquadVertex (Rate-limit aware)</title>

<!-- Firebase compat (kept) -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js "></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js "></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js "></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js "></script>
<!-- Prism.js for syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<style>
:root{
  --bg:#0f0f0f;--card:rgba(30,30,40,0.85);--muted:#b0b0b0;--gold:#ffd700;--accent:linear-gradient(45deg,#ffd700,#ff8c00);
}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family: "Segoe UI", Tahoma, Verdana, sans-serif; background:var(--bg); color:#fff; padding:18px; min-height:100vh}
.container{max-width:1200px;margin:0 auto}
.header{background:var(--card);padding:18px;border-radius:12px;border:1px solid rgba(255,215,0,0.12);text-align:center;margin-bottom:14px}
.header h1{background:var(--accent);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:1.8rem}
.controls{display:grid;grid-template-columns:1fr 380px;gap:14px;margin-bottom:14px}
@media(max-width:920px){.controls{grid-template-columns:1fr}}
.card{background:var(--card);padding:14px;border-radius:10px;border:1px solid rgba(255,215,0,0.06)}
.input{display:block;width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,215,0,0.06);background:rgba(0,0,0,0.32);color:#fff;margin-bottom:8px}
.row{display:flex;gap:8px;align-items:center}
.btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;background:var(--accent);color:#070707;font-weight:700}
.small{padding:6px 8px;font-size:13px}
.stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px;margin-bottom:12px}
.stat{background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(255,255,255,0.01));padding:10px;border-radius:8px;text-align:center;border:1px solid rgba(255,215,0,0.06)}
.stat .v{font-weight:800;background:var(--accent);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:1.1rem}
.tabs{display:flex;gap:8px;margin:12px 0;border-bottom:1px solid rgba(255,215,0,0.04)}
.tab{padding:8px 12px;cursor:pointer}
.tab.active{color:var(--gold);border-bottom:3px solid var(--gold)}
.tab-content{display:none;padding-top:12px}
.tab-content.active{display:block}
.table{overflow:auto}
table{width:100%;border-collapse:collapse}
th,td{padding:8px;text-align:left;border-bottom:1px solid rgba(255,215,0,0.03);font-size:13px}
th{background:rgba(255,215,0,0.04);color:var(--gold)}
.file-type{background:rgba(255,215,0,0.06);padding:4px 6px;border-radius:6px;font-size:12px}
.loading{color:var(--muted);padding:10px}
.error{background:rgba(239,68,68,0.08);border:1px solid #ef4444;color:#ffb3b3;padding:10px;border-radius:8px;margin:8px 0}
.controls-right{display:flex;flex-direction:column;gap:10px}
.footer-note{color:var(--muted);font-size:12px;margin-top:8px}

/* Syntax highlighting container */
.code-container {
  position: relative;
  margin-top: 8px;
}
.code-actions {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 6px;
  z-index: 10;
}
.copy-btn {
  padding: 4px 8px;
  border-radius: 4px;
  background: rgba(0,0,0,0.6);
  color: white;
  border: 1px solid rgba(255,255,255,0.1);
  cursor: pointer;
  font-size: 12px;
}
.copy-btn:hover {
  background: rgba(0,0,0,0.8);
}
pre[class*="language-"] {
  margin-top: 28px;
  border-radius: 8px;
  overflow: auto;
  max-height: 420px;
}

/* Comments section */
.comments-section {
  margin-top: 16px;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
}
.comment-item {
  padding: 8px;
  margin-bottom: 8px;
  background: rgba(255,255,255,0.05);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}
.comment-meta {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 4px;
}
.comment-text {
  font-size: 13px;
}
.no-comments {
  color: var(--muted);
  font-style: italic;
  text-align: center;
  padding: 12px;
}
</style>
</head>
<body>
<div class="container">
  <div class="header card">
    <h1>üöÄ GitHub Repo Analyzer ‚Äî SquadVertex (Enhanced)</h1>
    <div style="color:var(--muted);margin-top:6px">Overview & Details fixed ‚Ä¢ Lazy content fetch ‚Ä¢ Rate-limit aware ‚Ä¢ Token support ‚Ä¢ Syntax highlighting ‚Ä¢ Copy code ‚Ä¢ Comment extraction</div>
  </div>

  <div class="controls">
    <div class="card">
      <div style="margin-bottom:10px"><strong>Repository</strong></div>
      <input id="owner" class="input" placeholder="owner" value="PRINCE16082007">
      <input id="repo" class="input" placeholder="repo" value="SquadVertex">
      <input id="branch" class="input" placeholder="branch" value="main">
      <input id="root" class="input" placeholder="root path (optional)" value="test-files">

      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="extensions" class="input" style="flex:1" placeholder=".js,.py" value=".js,.ts,.py,.html,.css,.json,.md">
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <input id="minSize" class="input" style="width:120px" type="number" placeholder="min size bytes" value="0">
        <input id="maxContentFetch" class="input" style="width:120px" type="number" placeholder="content fetch N" value="10" title="Max files to fetch content for (0 = none)">
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="ghToken" class="input" placeholder="GitHub token (optional)" title="Use a personal token to increase rate limit">
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="analyzeBtn" class="btn">üîÑ Analyze</button>
        <button id="fetchTopContentBtn" class="btn small" style="background:linear-gradient(45deg,#60a5fa,#3b82f6)">üìÑ Fetch top N file content</button>
        <button id="exportBtn" class="btn small" style="background:linear-gradient(45deg,#4ade80,#22c55e)">üì• Export</button>
      </div>

      <div class="footer-note">
        Tip: By default we do NOT fetch each file‚Äôs content (lazy). Use "Fetch top N" or click a file to load content. This saves API tokens & bandwidth.
      </div>
    </div>

    <div class="card controls-right">
      <div style="margin-bottom:6px"><strong>Quick stats</strong></div>
      <div class="stats-grid" id="quickStats">
        <div class="stat"><div class="v" id="totalFiles">0</div><div class="label" style="color:var(--muted)">Files</div></div>
        <div class="stat"><div class="v" id="totalSize">0 Bytes</div><div class="label" style="color:var(--muted)">Total size</div></div>
        <div class="stat"><div class="v" id="largestFile">‚Äî</div><div class="label" style="color:var(--muted)">Largest</div></div>
        <div class="stat"><div class="v" id="avgSize">‚Äî</div><div class="label" style="color:var(--muted)">Average</div></div>
      </div>

      <div style="margin-top:6px"><strong>Search / Filter</strong></div>
      <input id="searchFilter" class="input" placeholder="Filter by filename or path">

      <div style="margin-top:6px"><strong>Charts</strong></div>
      <div style="display:flex;gap:8px">
        <button id="showChartsBtn" class="btn small">Show charts</button>
        <button id="loadCacheBtn" class="btn small" style="background:linear-gradient(45deg,#f59e0b,#f97316)">Load cache</button>
      </div>

      <div id="rateInfo" class="footer-note" style="margin-top:8px;color:var(--muted)"></div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="card" style="margin-bottom:12px">
    <div class="tabs">
      <div class="tab active" data-tab="overview">üìà Overview</div>
      <div class="tab" data-tab="files">üìÅ Files</div>
      <div class="tab" data-tab="charts">üìä Charts</div>
      <div class="tab" data-tab="details">üìã Details</div>
    </div>

    <!-- Overview: now contains the stats + small summary -->
    <div id="overview" class="tab-content active">
      <div style="display:flex;gap:12px;flex-wrap:wrap">
        <div style="flex:1">
          <h3 style="margin-bottom:8px">Summary</h3>
          <div id="summaryText" style="color:var(--muted)">No analysis run yet.</div>
        </div>
        <div style="width:360px">
          <h3 style="margin-bottom:8px">Top files</h3>
          <div id="topFilesList" style="color:var(--muted)">‚Äî</div>
        </div>
      </div>
    </div>

    <!-- Files table -->
    <div id="files" class="tab-content">
      <div class="table">
        <table>
          <thead><tr><th>Name</th><th>Path</th><th>Size</th><th>Type</th><th>Lines</th><th>Actions</th></tr></thead>
          <tbody id="filesTableBody"></tbody>
        </table>
      </div>
      <div id="filesNote" style="color:var(--muted);margin-top:8px">Click üîç to load file content (this will perform a single request for that file).</div>
    </div>

    <!-- Charts -->
    <div id="charts" class="tab-content">
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div style="background:rgba(0,0,0,0.25);padding:10px;border-radius:8px"><canvas id="typeChart"></canvas></div>
        <div style="background:rgba(0,0,0,0.25);padding:10px;border-radius:8px"><canvas id="sizeChart"></canvas></div>
      </div>
    </div>

    <!-- Details -->
    <div id="details" class="tab-content">
      <div id="fileDetailsInner" style="color:var(--muted)">Select a file to view details.</div>
    </div>
  </div>

  <div id="loading" class="loading" style="display:none"></div>
  <div id="error" class="error" style="display:none"></div>
</div>

<script>
/* ========= Globals + safe defaults ========= */
window.analysisData = window.analysisData || []; // array of file objects
window.currentFile = window.currentFile || null;
window.charts = window.charts || {typeChart:null, sizeChart:null};
window.currentCode = ""; // Store current code for copying

/* ========= Helpers ========= */
function el(id){ return document.getElementById(id); }
function showLoading(txt){ el('loading').style.display='block'; el('loading').textContent=txt || 'Working...'; }
function hideLoading(){ el('loading').style.display='none'; }
function showError(msg){ el('error').style.display='block'; el('error').textContent = msg; }
function hideError(){ el('error').style.display='none'; el('error').textContent = ''; }
function formatBytes(bytes){ if(!bytes && bytes !== 0) return '0 Bytes'; const k=1024; const sizes=['Bytes','KB','MB','GB']; const i = bytes===0?0:Math.floor(Math.log(bytes)/Math.log(k)); return (bytes/Math.pow(k,i)).toFixed(2)+' '+sizes[i]; }
function getFileType(name){ const ext = (name.split('.').pop()||'').toLowerCase(); const map={'js':'JavaScript','ts':'TypeScript','py':'Python','html':'HTML','css':'CSS','json':'JSON','md':'Markdown'}; return map[ext]||(ext?ext.toUpperCase():'Unknown'); }
function safeDecodeURIPath(p){ try { return decodeURIComponent(p); } catch(e){ return p; } }

/* ========= Tab switching ========= */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', () => {
    const tab = t.dataset.tab;
    document.querySelectorAll('.tab').forEach(x=>x.classList.toggle('active', x===t));
    document.querySelectorAll('.tab-content').forEach(c=> c.classList.toggle('active', c.id===tab));
  });
});

/* ========= Rate-limit aware fetch wrapper ========= */
async function ghFetch(url, token){
  const headers = { 'Accept': 'application/vnd.github.v3+json' };
  if(token) headers['Authorization'] = 'token ' + token;
  const res = await fetch(url, { headers });
  // return response and parsed headers info
  const remaining = parseInt(res.headers.get('x-ratelimit-remaining') || '0', 10);
  const resetEpoch = parseInt(res.headers.get('x-ratelimit-reset') || '0', 10);
  return { res, remaining, resetEpoch };
}

/* ========= Extract TODO and other comments from code ========= */
function extractComments(code, language) {
  const comments = [];
  
  // Split code into lines for processing
  const lines = code.split('\n');
  
  // Regex patterns for different comment styles
  const patterns = {
    js: [
      { regex: /\/\*.*?\*\//gs, type: 'block' },   // /* ... */
      { regex: /\/\/.*$/gm, type: 'line' }         // // ...
    ],
    ts: [
      { regex: /\/\*.*?\*\//gs, type: 'block' },
      { regex: /\/\/.*$/gm, type: 'line' }
    ],
    py: [
      { regex: /""".*?"""/gs, type: 'block' },     // """ ... """
      { regex: /'''.*?'''/gs, type: 'block' },     // ''' ... '''
      { regex: /#.*$/gm, type: 'line' }            // # ...
    ],
    html: [
      { regex: /<!--.*?-->/gs, type: 'block' }     // <!-- ... -->
    ],
    css: [
      { regex: /\/\*.*?\*\//gs, type: 'block' }    // /* ... */
    ]
  };
  
  // Get appropriate patterns for the language
  const langPatterns = patterns[language] || patterns.js;
  
  lines.forEach((line, index) => {
    const lineNumber = index + 1;
    
    langPatterns.forEach(pattern => {
      const matches = line.match(pattern.regex);
      if (matches) {
        matches.forEach(match => {
          // Check if the match contains TODO, FIXME, etc.
          const upperMatch = match.toUpperCase();
          if (upperMatch.includes('TODO') || upperMatch.includes('FIXME') || upperMatch.includes('BUG') || 
              upperMatch.includes('HACK') || upperMatch.includes('NOTE') || upperMatch.includes('OPTIMIZE')) {
            
            // Clean up the comment text
            let cleanMatch = match
              .replace(/\/\*/, '')  // Remove opening block comment
              .replace(/\*\//, '')  // Remove closing block comment
              .replace(/\/\//, '')  // Remove line comment prefix
              .replace(/#/g, '')    // Remove hash from Python comments
              .replace(/<!--/g, '') // Remove HTML comment start
              .replace(/-->/g, '')  // Remove HTML comment end
              .replace(/"""/g, '')  // Remove docstring start/end
              .replace(/'''/g, '')  // Remove docstring start/end
              .trim();
              
            comments.push({
              type: pattern.type,
              line: lineNumber,
              text: cleanMatch,
              original: match
            });
          }
        });
      }
    });
  });
  
  return comments;
}

/* ========= Render comments section ========= */
function renderComments(comments) {
  const target = el('fileDetailsInner');
  const commentsSection = document.createElement('div');
  commentsSection.className = 'comments-section';
  
  if (comments.length === 0) {
    commentsSection.innerHTML = '<div class="no-comments">No TODOs, FIXMEs, or other important comments found</div>';
    return commentsSection;
  }
  
  let commentsHTML = '<h4>Important Comments Found:</h4>';
  comments.forEach(comment => {
    commentsHTML += `
      <div class="comment-item">
        <div class="comment-meta">Line ${comment.line} ‚Ä¢ ${comment.type} comment</div>
        <div class="comment-text">${escapeHtml(comment.text)}</div>
      </div>
    `;
  });
  
  commentsSection.innerHTML = commentsHTML;
  return commentsSection;
}

/* ========= Main analyze function (NO bulk content fetching by default) ========= */
async function analyzeRepo(){
  hideError();
  showLoading('Fetching repo tree from GitHub...');
  try{
    const owner = el('owner').value.trim(), repo = el('repo').value.trim(), branch = el('branch').value.trim() || 'main';
    if(!owner || !repo) throw new Error('Owner & repo required');
    const root = (el('root').value || '').trim();
    const extensions = (el('extensions').value || '').split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
    const minSize = parseInt(el('minSize').value) || 0;
    const token = (el('ghToken').value || '').trim();

    // fetch the tree (recursive)
    const treeUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/git/trees/${encodeURIComponent(branch)}?recursive=1`;
    const { res, remaining, resetEpoch } = await ghFetch(treeUrl, token);
    // rate info
    el('rateInfo').textContent = `GitHub rate remaining: ${remaining} ‚Äî reset ${ new Date(resetEpoch*1000).toLocaleString() }`;

    if(!res.ok){
      const txt = await res.text();
      throw new Error(`GitHub API error ${res.status}: ${txt.substring(0,200)}`);
    }
    const data = await res.json();
    if(!data.tree) throw new Error('Invalid tree response');

    // filter blobs
    let files = data.tree.filter(i => i.type === 'blob');
    if(root){
      const rootNorm = root.replace(/^\/*/,'').replace(/\/*$/,'') + '/';
      files = files.filter(f => f.path.startsWith(rootNorm));
    }
    // apply ext and minSize
    files = files.filter(item => {
      const pathLower = item.path.toLowerCase();
      const extMatch = extensions.length ? extensions.some(ext => pathLower.endsWith(ext)) : true;
      const sizeOk = (typeof item.size === 'number') ? item.size > minSize : true;
      return extMatch && sizeOk;
    });

    // Build minimal file objects WITHOUT fetching content (lazy)
    const built = files.map(f => ({
      path: f.path,
      name: f.path.split('/').pop(),
      size: f.size || 0,
      url: `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${encodeURI(f.path)}`,
      type: getFileType(f.path),
      lines: null,  // unknown until we fetch content
      columns: null
    }));

    // Save
    window.analysisData = built;
    updateUIAfterAnalysis(built);

    hideLoading();

    // If remaining low, warn user and avoid any automatic content fetches
    if(remaining < 5){
      showError(`Warning: GitHub rate limit low (${remaining} remaining). Avoid fetching many files now or provide a personal token.`);
    }

  }catch(err){
    hideLoading();
    showError('Analysis error: ' + (err.message || err));
    console.error(err);
  }
}

/* ========= Update UI (Overview, Files table, Charts) ========= */
function updateUIAfterAnalysis(files){
  // Stats
  const totalFiles = files.length;
  const totalSize = files.reduce((s,f)=>s + (f.size||0), 0);
  const largest = files.reduce((best,f)=> (!best || (f.size||0) > (best.size||0)) ? f : best, null);
  const avg = totalFiles ? Math.round(totalSize/totalFiles) : 0;

  el('totalFiles').textContent = totalFiles;
  el('totalSize').textContent = formatBytes(totalSize);
  el('largestFile').textContent = largest ? `${largest.name} ‚Äî ${formatBytes(largest.size)}` : '‚Äî';
  el('avgSize').textContent = avg ? formatBytes(avg) : '‚Äî';

  // Summary text
  el('summaryText').textContent = `Found ${totalFiles} files (${formatBytes(totalSize)}). Largest: ${largest ? largest.name : '‚Äî'}. Average size: ${avg ? formatBytes(avg) : '‚Äî'}. Content NOT fetched by default to save rate tokens. Click a file to load content on-demand.`;

  // Top files list (by size)
  const top = [...files].sort((a,b)=> (b.size||0) - (a.size||0)).slice(0,8);
  el('topFilesList').innerHTML = top.map(t=> `<div style="margin-bottom:6px">${t.name} ‚Äî <span style="color:var(--muted)">${formatBytes(t.size)}</span></div>`).join('') || '‚Äî';

  // Files table (apply current search filter)
  renderFilesTable(files);

  // populate charts (but do not fetch content)
  renderCharts(files);
}

/* ========= Render files table ========= */
function renderFilesTable(files){
  const search = (el('searchFilter').value || '').toLowerCase();
  const filtered = files.filter(f=> (f.name + ' ' + f.path).toLowerCase().includes(search));
  const tbody = el('filesTableBody');
  tbody.innerHTML = '';

  filtered.forEach(f=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${f.name}</td>
      <td style="max-width:420px;word-break:break-all">${f.path}</td>
      <td>${formatBytes(f.size)}</td>
      <td><span class="file-type">${f.type}</span></td>
      <td>${f.lines === null ? '‚Äî' : f.lines}</td>
      <td style="white-space:nowrap">
        <button class="btn small" onclick="loadSingleFile('${escapeForAttr(f.url)}','${escapeForAttr(f.path)}')">üîç Load</button>
        <button class="btn small" style="background:linear-gradient(45deg,#3b82f6,#2563eb)" onclick="downloadDirect('${escapeForAttr(f.url)}','${escapeForAttr(f.name)}')">üì•</button>
      </td>
    `;
    tbody.appendChild(tr);
  });
}

/* ========= Charts ========= */
function renderCharts(files){
  try{
    // type distribution
    const counts = {};
    files.forEach(f=> counts[f.type] = (counts[f.type]||0) + 1 );
    const labels = Object.keys(counts).slice(0,20);
    const data = labels.map(l=> counts[l]);

    if(window.charts.typeChart) window.charts.typeChart.destroy();
    const ctx1 = el('typeChart').getContext('2d');
    window.charts.typeChart = new Chart(ctx1, {
      type: 'doughnut',
      data: { labels, datasets: [{ data }] },
      options: { plugins:{legend:{position:'bottom'}}}
    });

    // top sizes
    const top = [...files].sort((a,b)=> (b.size||0)-(a.size||0)).slice(0,10);
    const sizeLabels = top.map(t=> t.name);
    const sizeValues = top.map(t=> Math.round((t.size||0)/1024)); // KB
    if(window.charts.sizeChart) window.charts.sizeChart.destroy();
    const ctx2 = el('sizeChart').getContext('2d');
    window.charts.sizeChart = new Chart(ctx2, {
      type:'bar',
      data: { labels: sizeLabels, datasets: [{ label: 'Size (KB)', data: sizeValues }] },
      options: { indexAxis: 'y', plugins:{legend:{display:false}} }
    });
  }catch(e){
    console.warn('charts err', e);
  }
}

/* ========= On-demand single file load (safe: checks rate limit, size) ========= */
async function loadSingleFile(rawUrl, path){
  hideError();
  showLoading('Fetching file content (on-demand)...');
  try{
    const token = (el('ghToken').value || '').trim();
    // small rate-limit safety: do a HEAD or conditional call? We do a fetch and read headers
    // Use the GitHub raw URL (raw.githubusercontent) which doesn't provide rate-limit headers.
    // Instead, use the API blob endpoint to also grab size and content with token-aware headers if token is present.
    // We'll try the raw URL first (fast), but if token is present use API blob to be counted toward rate-limits accurately.

    // If token provided, use GitHub API contents endpoint for path parsing
    if(token){
      // extract owner/repo/branch from inputs to build API contents URL
      const owner = el('owner').value.trim(), repo = el('repo').value.trim(), branch = el('branch').value.trim() || 'main';
      const apiUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
      const { res, remaining } = await ghFetch(apiUrl, token);
      el('rateInfo').textContent = `GitHub rate remaining: ${remaining}`;
      if(!res.ok) {
        // fallback to raw if content endpoint blocked
        const text = await (await fetch(rawUrl)).text();
        showFileContent(path, text);
        return;
      }
      const blobMeta = await res.json();
      // if content comes base64 encoded
      if(blobMeta && blobMeta.content){
        const content = atob(blobMeta.content.replace(/\s/g,''));
        showFileContent(path, content);
        // update lines/columns in analysisData
        const fileObj = window.analysisData.find(f => f.path === path);
        if(fileObj){ fileObj.lines = content.split(/\r\n|\n/).length; fileObj.columns = Math.max(...content.split(/\r\n|\n/).map(l=>l.length), 0); }
        renderFilesTable(window.analysisData);
        hideLoading();
        switchToDetails(path);
        return;
      } else {
        // fallback raw
        const text = await (await fetch(rawUrl)).text();
        showFileContent(path, text);
        hideLoading();
        switchToDetails(path);
        return;
      }
    } else {
      // No token -> use raw.githubusercontent which is fast but not rate-header-aware
      const r = await fetch(rawUrl);
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      const text = await r.text();
      showFileContent(path, text);
      // update stats
      const fileObj = window.analysisData.find(f => f.path === path);
      if(fileObj){ fileObj.lines = text.split(/\r\n|\n/).length; fileObj.columns = Math.max(...text.split(/\r\n|\n/).map(l=>l.length), 0); }
      renderFilesTable(window.analysisData);
      hideLoading();
      switchToDetails(path);
    }
  }catch(err){
    hideLoading();
    showError('File load error: ' + (err.message || err));
    console.error(err);
  }
}

function showFileContent(path, content){
  const target = el('fileDetailsInner');
  const safePath = safeDecodeURIPath(path);
  
  // Determine language for syntax highlighting
  const extension = path.split('.').pop().toLowerCase();
  let language = 'clike'; // default
  
  if (extension === 'js' || extension === 'ts' || extension === 'json') {
    language = extension;
  } else if (extension === 'py') {
    language = 'python';
  } else if (extension === 'html' || extension === 'htm') {
    language = 'markup';
  } else if (extension === 'css') {
    language = 'css';
  } else if (extension === 'md') {
    language = 'markdown';
  }
  
  // Store content for copy functionality
  window.currentCode = content;
  
  // Escape HTML entities in content
  const escapedContent = escapeHtml(content);
  
  // Extract comments from the code
  const comments = extractComments(content, extension);
  
  // Create the file content display with syntax highlighting and copy button
  target.innerHTML = `
    <h3 style="margin-top:0">${safePath}</h3>
    <div style="color:var(--muted);margin-bottom:8px">Size: ${content.length} bytes ‚Äî Loaded on demand</div>
    <div class="code-container">
      <div class="code-actions">
        <button class="copy-btn" onclick="copyCode()">üìã Copy</button>
      </div>
      <pre><code class="language-${language}">${escapedContent}</code></pre>
    </div>
  `;
  
  // Add comments section if any were found
  if (comments.length > 0) {
    const commentsSection = renderComments(comments);
    target.appendChild(commentsSection);
  }
  
  // Highlight the code using Prism.js
  setTimeout(() => {
    Prism.highlightAllUnder(target);
  }, 10);
}

/* ========= Copy code functionality ========= */
function copyCode() {
  if (!window.currentCode) {
    showError('No code available to copy');
    return;
  }
  
  navigator.clipboard.writeText(window.currentCode)
    .then(() => {
      // Show temporary success indicator
      const btn = document.querySelector('.copy-btn');
      const originalText = btn.textContent;
      btn.textContent = '‚úì Copied!';
      setTimeout(() => {
        btn.textContent = originalText;
      }, 2000);
    })
    .catch(err => {
      showError('Failed to copy code: ' + err);
    });
}

/* ========= Bulk fetch for top N files (controlled) ========= */
async function fetchTopNContent(){
  hideError();
  const maxN = parseInt(el('maxContentFetch').value) || 0;
  if(maxN <= 0){ alert('Set a positive number in "content fetch N" to use this feature.'); return; }
  if(!window.analysisData || window.analysisData.length === 0){ alert('Run analysis first.'); return; }

  const token = (el('ghToken').value || '').trim();
  // sort top by size
  const top = [...window.analysisData].sort((a,b)=> (b.size||0)-(a.size||0)).slice(0,maxN);
  showLoading(`Fetching content for top ${top.length} files... (this uses ${top.length} requests)`);
  let counter = 0;
  for(const f of top){
    try{
      await loadSingleFile(f.url, f.path);
      counter++;
      showLoading(`Fetched ${counter}/${top.length}...`);
      // small delay to be gentle on API
      await new Promise(r=>setTimeout(r, 250));
    }catch(e){
      console.warn('top fetch err', e);
    }
  }
  hideLoading();
  alert(`Done fetching content for ${counter}/${top.length} files.`);
}

/* ========= Utilities ========= */
function escapeForAttr(s){ return (s||'').replace(/'/g,"\\'").replace(/"/g,'\\"'); }
function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function downloadDirect(url, name){ fetch(url).then(r=>r.blob()).then(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download = name || 'file'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),3000)}).catch(e=>alert('Download failed: '+e)); }
function switchToDetails(path){ document.querySelectorAll('.tab').forEach(t=> t.classList.toggle('active', t.dataset.tab==='details')); document.querySelectorAll('.tab-content').forEach(c=> c.classList.toggle('active', c.id==='details')); }

/* ========= Event binds ========= */
el('analyzeBtn').addEventListener('click', analyzeRepo);
el('fetchTopContentBtn').addEventListener('click', fetchTopNContent);
el('exportBtn').addEventListener('click', ()=> {
  if(!window.analysisData || window.analysisData.length===0){ alert('No data'); return; }
  const blob = new Blob([JSON.stringify(window.analysisData,null,2)], {type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='analysis.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),4000);
});
el('searchFilter').addEventListener('input', ()=> renderFilesTable(window.analysisData || []));

// load cache
el('loadCacheBtn').addEventListener('click', ()=>{
  try{
    const raw = localStorage.getItem('lastAnalysis');
    if(!raw) return alert('No cached analysis found');
    const obj = JSON.parse(raw);
    if(!obj.data) return alert('Invalid cache');
    window.analysisData = obj.data;
    updateUIAfterAnalysis(window.analysisData);
    alert('Loaded cached analysis from ' + (obj.timestamp||'unknown'));
  }catch(e){ alert('Load cache failed: '+e) }
});

/* ========= Local caching after analysis (auto) ========= */
(function autoCacheHook(){
  // after each successful analyzeRepo, we cache inside analyzeRepo. But if you want to save manually, do:
  const origAnalyze = analyzeRepo;
  analyzeRepo = async function(){
    await origAnalyze();
    try{
      if(window.analysisData) localStorage.setItem('lastAnalysis', JSON.stringify({timestamp:new Date().toISOString(), data: window.analysisData}));
    }catch(e){ console.warn('cache fail', e); }
  };
})();

/* ========= Initial console note ========= */
console.log('Optimized analyzer loaded ‚Äî Overview & Details fixed. Analysis is lazy by default. Use token to raise rate limits.');
</script>
</body>
</html>