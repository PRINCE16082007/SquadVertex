<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Full Orbit Game ‚Äî Intelligent Fun Build</title>

<style>
:root{
  --bg:#030916;
  --panel:#0a1833;
  --accent:#64c2ff;
  --good:#6affd1;
  --danger:#ff6b6b;
  --text:#eaf6ff;
  --muted:#9fc9ff;
}
*{box-sizing:border-box;margin:0;padding:0}
body{
  margin:0;
  background:radial-gradient(circle at top,#071a38,#02060d 70%);
  color:var(--text);
  font-family:Inter,Poppins,Arial,sans-serif;
  overflow:hidden;
}
.container{
  max-width:1200px;
  margin:auto;
  padding:18px;
  width:100%;
  height:100vh;
  display:flex;
  flex-direction:column;
}
header{
  font-size:1.4rem;
  font-weight:900;
  margin-bottom:12px;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
.fullscreen-btn {
  background:var(--accent);
  color:#000;
  border:none;
  padding:4px 10px;
  border-radius:8px;
  font-weight:700;
  cursor:pointer;
  font-size:0.9rem;
}
.card{
  background:linear-gradient(180deg,#081b3a,#040b18);
  border-radius:16px;
  padding:14px;
  border:1px solid rgba(255,255,255,.05);
  box-shadow:0 30px 60px rgba(0,0,0,.8);
  position:relative;
  flex-grow:1;
  display:flex;
  flex-direction:column;
}
.play{
  position:relative;
  flex-grow:1;
  min-height:500px;
  border-radius:14px;
  overflow:hidden;
  background:radial-gradient(circle,#0a2244,#02060d);
  display:flex;
  align-items:center;
  justify-content:center;
}
canvas{position:absolute;inset:0;width:100%;height:100%}
.earth{
  position:absolute;
  left:50%;top:50%;
  transform:translate(-50%,-50%);
  font-size:66px;
  filter:drop-shadow(0 0 28px rgba(100,194,255,.8));
  pointer-events:none;
}
.hud{
  position:absolute;
  right:16px;top:16px;
  background:rgba(6,16,32,.75);
  padding:12px 16px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.06);
  display:flex;
  gap:16px;
}
.hud div{text-align:right}
.hud strong{font-size:1.1rem}
.hud span{font-size:.75rem;color:var(--muted)}

.ai{
  position:absolute;
  left:16px;top:16px;
  background:rgba(255,255,255,.05);
  padding:8px 12px;
  border-radius:10px;
  font-size:.78rem;
  border:1px solid rgba(255,255,255,.08);
}
.combo{
  position:absolute;
  left:50%;
  bottom:18px;
  transform:translateX(-50%);
  font-weight:800;
  color:var(--good);
  opacity:0;
  transition:.2s;
}
.combo.show{opacity:1}

.difficulty-bar {
  position:absolute;
  bottom:16px;
  left:16px;
  background:rgba(0,0,0,0.5);
  padding:6px 10px;
  border-radius:10px;
  font-size:0.8rem;
  border:1px solid var(--accent);
  color:var(--accent);
  pointer-events:none;
}

.boss-timer {
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  font-size:1.8rem;
  font-weight:800;
  color:var(--danger);
  opacity:0;
  pointer-events:none;
  text-shadow:0 0 10px var(--danger);
}
.boss-timer.active { opacity:1; }

.warning {
  position:absolute;
  top:20%;
  left:50%;
  transform:translateX(-50%);
  font-size:1.2rem;
  font-weight:700;
  color:var(--danger);
  opacity:0;
  pointer-events:none;
  text-shadow:0 0 10px var(--danger);
}
.warning.active { opacity:1; }

#rotatePrompt {
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  z-index:10000;
  color:white;
  font-size:1.2rem;
  font-weight:bold;
  display:none;
}
#rotatePrompt div {
  margin-top:20px;
  color:var(--accent);
}
</style>
</head>

<body>

<div id="rotatePrompt">
  üì± Please rotate your device<br>to landscape mode!<br>
  <div>Then tap anywhere to continue</div>
</div>

<div class="container">
<header>
  <span>üåå Full Orbit Game ‚Äî Intelligent Fun Build</span>
  <button class="fullscreen-btn" id="fsBtn">‚õ∂ Fullscreen</button>
</header>

<div class="card">
<div class="play">
<canvas id="c"></canvas>
<div class="earth">üåç</div>

<div class="ai" id="ai">AI: calibrating‚Ä¶</div>
<div class="difficulty-bar" id="diffBar">Level: Easy</div>
<div class="boss-timer" id="bossTimer">BOSS INCOMING!</div>
<div class="warning" id="warning">‚ö†Ô∏è AVOID THE ALIEN!</div>

<div class="hud">
  <div><strong id="score">0</strong><br><span>Score</span></div>
  <div><strong id="comboVal">0</strong><br><span>Combo</span></div>
  <div><strong id="misses">0</strong><br><span>Misses</span></div>
</div>

<div class="combo" id="comboText">COMBO!</div>
</div>
</div>
</div>

<script>
/* ================= FULLSCREEN + ORIENTATION ================= */
const fsBtn = document.getElementById('fsBtn');
const rotatePrompt = document.getElementById('rotatePrompt');
const diffBar = document.getElementById('diffBar');
const bossTimer = document.getElementById('bossTimer');
const warning = document.getElementById('warning');

let isFullscreen = false;
const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

function enterFullscreen() {
  const elem = document.documentElement;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { // Safari
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { // IE11
    elem.msRequestFullscreen();
  }
}

function lockLandscape() {
  if (!screen.orientation) return false;
  try {
    return screen.orientation.lock('landscape').then(() => true).catch(() => false);
  } catch (e) {
    return false;
  }
}

function showRotatePrompt() {
  rotatePrompt.style.display = 'flex';
  document.body.style.overflow = 'hidden';
}

function hideRotatePrompt() {
  rotatePrompt.style.display = 'none';
  document.body.style.overflow = '';
}

fsBtn?.addEventListener('click', async () => {
  if (isFullscreen) return;
  enterFullscreen();
});

document.addEventListener('fullscreenchange', async () => {
  isFullscreen = !!document.fullscreenElement;
  if (isFullscreen) {
    document.querySelector('header').style.display = 'none';
    document.querySelector('.container').style.padding = '0';
    document.body.style.background = 'black';
    if (isMobile) {
      const locked = await lockLandscape();
      if (!locked) {
        setTimeout(() => {
          if (window.innerWidth < window.innerHeight) {
            showRotatePrompt();
          }
        }, 500);
      }
    }
  } else {
    document.querySelector('header').style.display = 'flex';
    document.querySelector('.container').style.padding = '18px';
    document.body.style.background = '';
    hideRotatePrompt();
  }
});

document.addEventListener('pointerdown', () => {
  if (rotatePrompt.style.display === 'flex') {
    hideRotatePrompt();
  }
});

/* ================= CORE ================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("comboVal");
const missEl = document.getElementById("misses");
const aiEl = document.getElementById("ai");
const comboText = document.getElementById("comboText");

let DPR = Math.max(1, window.devicePixelRatio || 1), W, H;
function resize() {
  W = canvas.offsetWidth; H = canvas.offsetHeight;
  canvas.width = W * DPR; canvas.height = H * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener("resize", resize);
resize();

/* ================= GAME STATE ================= */
let orbs = [];
let aliens = [];
let bombs = [];
let bosses = [];
let score = 0, combo = 0, misses = 0;
let clicks = 0, hits = 0, reactionTimes = [];
let lastBossTime = Date.now(); // Track last boss spawn
let isDistorting = false; // For alien punishment effect
let distortionIntensity = 0;
let distortionDuration = 0;

/* ================= SKILL INDEX ================= */
function skillIndex() {
  const acc = hits / Math.max(1, clicks);
  const avg = reactionTimes.reduce((a, b) => a + b, 0) / Math.max(1, reactionTimes.length);
  const reactScore = Math.max(0, 1 - avg / 1200);
  return Math.min(1, (acc * 0.6 + reactScore * 0.4));
}

/* ================= DIFFICULTY SYSTEM ================= */
function getDifficultyLevel(skill) {
  if (skill < 0.15) return { level: "Easy", color: "#6affd1", orbCount: 15, speed: 0.003, shieldProb: 0.1 };
  if (skill < 0.35) return { level: "Medium", color: "#64c2ff", orbCount: 18, speed: 0.006, shieldProb: 0.15 };
  if (skill < 0.55) return { level: "Hard", color: "#ffaa00", orbCount: 20, speed: 0.009, shieldProb: 0.2 };
  if (skill < 0.75) return { level: "Pro", color: "#ff6b6b", orbCount: 22, speed: 0.011, shieldProb: 0.25 };
  return { level: "Elite", color: "#d400ff", orbCount: 25, speed: 0.012, shieldProb: 0.3 };
}

/* ================= ORB TYPES ================= */
const TYPES = [
  { emoji: "ü™®", score: 1, shield: false },
  { emoji: "üíé", score: 3, shield: false },
  { emoji: "üåü", score: 5, shield: false },
  { emoji: "üõ°Ô∏è", score: 8, shield: true }
];

/* ================= SPAWN SYSTEM ================= */
function spawn() {
  const skill = skillIndex();
  const diff = getDifficultyLevel(skill);
  
  // Update difficulty display
  diffBar.textContent = `Level: ${diff.level}`;
  diffBar.style.color = diff.color;
  diffBar.style.borderColor = diff.color;

  // Spawn regular orbs
  if (orbs.length < diff.orbCount) {
    const t = TYPES[Math.floor(Math.random() * TYPES.length)];
    const baseSpeed = diff.speed;
    let speed = baseSpeed + Math.random() * 0.003;
    speed = Math.min(speed, 0.012);

    orbs.push({
      type: 'orb',
      angle: Math.random() * Math.PI * 2,
      radius: 100 + skill * 80 + Math.random() * 60,
      speed: (Math.random() < 0.5 ? -1 : 1) * speed,
      size: 30,
      emoji: t.emoji,
      score: t.score,
      shield: t.shield || Math.random() < diff.shieldProb,
      shieldHP: (t.shield || Math.random() < diff.shieldProb) ? 1 : 0,
      spawnTs: performance.now(),
      turnChance: skill * 0.005
    });
  }

  // Spawn aliens (rare)
  if (Math.random() < 0.005 && aliens.length === 0) {
    const angle = Math.random() * Math.PI * 2;
    warning.classList.add('active');
    setTimeout(() => warning.classList.remove('active'), 1500);
    
    aliens.push({
      type: 'alien',
      angle: angle,
      radius: 150 + Math.random() * 80,
      speed: (Math.random() < 0.5 ? -1 : 1) * 0.008,
      size: 40,
      emoji: "üëæ",
      spawnTs: performance.now()
    });
  }

  // Spawn bombs (very rare)
  if (Math.random() < 0.002 && bombs.length === 0) {
    const angle = Math.random() * Math.PI * 2;
    bombs.push({
      type: 'bomb',
      angle: angle,
      radius: 180 + Math.random() * 60,
      speed: (Math.random() < 0.5 ? -1 : 1) * 0.005,
      size: 35,
      emoji: "üí£",
      spawnTs: performance.now()
    });
  }

  // Spawn boss every 90 seconds
  if (Date.now() - lastBossTime > 90000 && bosses.length === 0) {
    bossTimer.classList.add('active');
    setTimeout(() => {
      bossTimer.classList.remove('active');
      const cores = [0, 0.5, 1].map((offset) => ({ angle: offset * Math.PI * 2, active: true }));
      
      bosses.push({
        type: 'boss',
        cores: cores, // 3 cores in a circle
        health: 3,
        size: 100,
        centerRadius: 200,
        angle: 0,
        speed: 0.001,
        spawnTs: performance.now()
      });
      lastBossTime = Date.now();
    }, 2000);
  }
}

setInterval(spawn, 800);

/* ================= INPUT ================= */
canvas.addEventListener("pointerdown", e => {
  clicks++;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cx = W / 2, cy = H / 2;

  // Check for orbs
  let hit = null, bestD = 9999;
  for (const o of orbs) {
    const ox = cx + Math.cos(o.angle) * o.radius;
    const oy = cy + Math.sin(o.angle) * o.radius;
    const d = Math.hypot(x - ox, y - oy);
    if (d < o.size && d < bestD) {
      hit = o; bestD = d;
    }
  }

  // Check for bombs
  for (const b of bombs) {
    const bx = cx + Math.cos(b.angle) * b.radius;
    const by = cy + Math.sin(b.angle) * b.radius;
    const d = Math.hypot(x - bx, y - by);
    if (d < b.size && d < bestD) {
      hit = b; bestD = d;
    }
  }

  // Check for boss cores
  for (const boss of bosses) {
    for (let i = 0; i < boss.cores.length; i++) {
      const core = boss.cores[i];
      if (!core.active) continue;
      const totalAngle = boss.angle + core.angle;
      const bx = cx + Math.cos(totalAngle) * boss.centerRadius;
      const by = cy + Math.sin(totalAngle) * boss.centerRadius;
      const d = Math.hypot(x - bx, y - by);
      if (d < boss.size / 3 && d < bestD) {
        // Hit active boss core!
        boss.cores[i].active = false;
        boss.health--;
        if (boss.health <= 0) {
          // Defeated!
          score += 100 * skillIndex(); // Massive bonus
          combo += 10; // Combo boost
          // Guaranteed bomb after win
          setTimeout(() => {
            bombs.push({
              type: 'bomb',
              angle: Math.random() * Math.PI * 2,
              radius: 180 + Math.random() * 60,
              speed: (Math.random() < 0.5 ? -1 : 1) * 0.005,
              size: 35,
              emoji: "üí£",
              spawnTs: performance.now()
            });
          }, 1000);
          bosses = bosses.filter(b => b !== boss);
        }
        hit = {type: 'boss'}; // Just to prevent orb/bomb hit
        break;
      }
    }
    if (hit && hit.type === 'boss') break;
  }

  if (hit) {
    hits++;
    reactionTimes.push(performance.now() - hit.spawnTs);

    if (hit.type === 'orb') {
      if (hit.shield && hit.shieldHP > 0) {
        hit.shieldHP--;
        return;
      }
      orbs = orbs.filter(o => o !== hit);
      score += hit.score;
      combo++;
      scoreEl.textContent = score;
      comboEl.textContent = combo;
      comboText.classList.add("show");
      setTimeout(() => comboText.classList.remove("show"), 300);
    } else if (hit.type === 'bomb') {
      // Bomb explosion!
      bombs = bombs.filter(b => b !== hit);
      const blastRadius = 150;
      // Destroy nearby orbs
      orbs = orbs.filter(o => {
        const ox = cx + Math.cos(o.angle) * o.radius;
        const oy = cy + Math.sin(o.angle) * o.radius;
        const d = Math.hypot(cx - ox, cy - oy);
        return d > blastRadius; // Keep orbs outside blast
      });
      // Break all shields
      orbs.forEach(o => { o.shieldHP = 0; });
      // Visual blast effect
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
      ctx.arc(cx, cy, blastRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  } else {
    combo = 0;
    misses++;
    comboEl.textContent = combo;
    missEl.textContent = misses;
  }
});

/* ================= ALIEN PUNISHMENT ================= */
function triggerAlienPunishment() {
  combo = Math.max(0, combo - Math.floor(combo * 0.1)); // Lose 10% combo
  score = Math.max(0, score - Math.floor(score * 0.1)); // Lose 10% score
  comboEl.textContent = combo;
  scoreEl.textContent = score;
  
  // Screen distortion effect
  isDistorting = true;
  distortionIntensity = 0.05;
  distortionDuration = 2000; // 2 seconds
}

/* ================= DRAW ================= */
function loop() {
  // Apply screen distortion if active
  if (isDistorting) {
    ctx.save();
    const timeLeft = distortionDuration;
    if (timeLeft <= 0) {
      isDistorting = false;
      ctx.restore();
    } else {
      const wave = Math.sin(Date.now() / 100) * distortionIntensity;
      ctx.transform(1 + wave, wave, wave, 1 + wave, 0, 0);
      distortionDuration -= 16;
    }
  }

  ctx.clearRect(0, 0, W, H);
  const cx = W / 2, cy = H / 2;
  const skill = skillIndex();
  aiEl.textContent = `AI Skill Index: ${skill.toFixed(2)}`;

  // Draw orbs
  for (const o of orbs) {
    if (Math.random() < o.turnChance) o.speed *= -1;
    o.angle += o.speed;

    const x = cx + Math.cos(o.angle) * o.radius;
    const y = cy + Math.sin(o.angle) * o.radius;

    if (o.shield && o.shieldHP > 0) {
      ctx.beginPath();
      ctx.strokeStyle = "rgba(106,255,209,.8)";
      ctx.lineWidth = 3;
      ctx.arc(x, y, o.size + 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.font = "30px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(o.emoji, x, y);
  }

  // Draw aliens
  for (const a of aliens) {
    a.angle += a.speed;
    const x = cx + Math.cos(a.angle) * a.radius;
    const y = cy + Math.sin(a.angle) * a.radius;
    ctx.font = "40px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "red";
    ctx.shadowBlur = 20;
    ctx.fillText(a.emoji, x, y);
    ctx.shadowBlur = 0;

    // Check if clicked alien
    const rect = canvas.getBoundingClientRect();
    const clickX = (rect.left + rect.right) / 2;
    const clickY = (rect.bottom + rect.top) / 2;
    const distToCenter = Math.hypot(W/2 - x, H/2 - y);
    if (distToCenter < a.size) {
      // Punish player!
      triggerAlienPunishment();
      aliens = []; // Remove alien
    }
  }

  // Draw bombs
  for (const b of bombs) {
    b.angle += b.speed;
    const x = cx + Math.cos(b.angle) * b.radius;
    const y = cy + Math.sin(b.angle) * b.radius;
    ctx.font = "35px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "orange";
    ctx.shadowBlur = 15;
    ctx.fillText(b.emoji, x, y);
    ctx.shadowBlur = 0;
  }

  // Draw boss
  for (const boss of bosses) {
    boss.angle += boss.speed;
    // Draw central core
    ctx.font = "100px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "purple";
    ctx.shadowBlur = 30;
    ctx.fillText("üëë", cx, cy);
    ctx.shadowBlur = 0;

    // Draw rotating cores
    for (const core of boss.cores) {
      if (!core.active) continue;
      const totalAngle = boss.angle + core.angle;
      const x = cx + Math.cos(totalAngle) * boss.centerRadius;
      const y = cy + Math.sin(totalAngle) * boss.centerRadius;
      ctx.font = "50px serif";
      ctx.fillText("üí•", x, y);
    }
  }

  if (isDistorting) ctx.restore();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>