<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Galaxy Portfolio — Admin & Manager</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
  <style>
    :root{--bg:#0f1620;--panel:#08101a;--accent:#ffd36b;--muted:#cbd6ef}
    html,body{margin:0;padding:0;background:var(--bg);color:#fff;font-family:Inter, Arial, sans-serif}
    .wrap{max-width:1240px;margin:28px auto;padding:18px}
    .top{display:flex;align-items:center;justify-content:space-between;gap:16px}
    h1{margin:0;font-size:20px;color:var(--accent)}
    .actions{display:flex;gap:10px}
    .btn{background:var(--accent);color:#08101a;border:none;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
    .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}.layout{display:flex;gap:20px;margin-top:18px}
.col{background:var(--panel);padding:14px;border-radius:12px;flex:1;min-height:420px}
.col.small{flex:0.45}

.cat-list{display:flex;flex-direction:column;gap:10px}
.cat-item{display:flex;align-items:center;gap:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);cursor:pointer}
.cat-item img{width:74px;height:54px;object-fit:cover;border-radius:6px}
.cat-item .meta{flex:1}
.meta .t{font-weight:700;color:var(--accent)}
.meta .d{color:var(--muted);font-size:13px}

.editor label{display:block;font-size:13px;color:var(--muted);margin-top:12px}
.editor input[type=text], .editor textarea{width:100%;padding:8px;margin-top:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#fff}
.editor textarea{min-height:90px}

.images-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px}
.img-card{background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;display:flex;flex-direction:column;gap:8px}
.img-card img{width:100%;height:120px;object-fit:cover;border-radius:6px}
.img-card .controls{display:flex;gap:6px;align-items:center}
.chip{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.03);font-size:13px}

.dropzone{border:2px dashed rgba(255,255,255,0.04);padding:18px;border-radius:10px;text-align:center;color:var(--muted)}
.small-muted{color:var(--muted);font-size:13px;margin-top:8px}

.drag-hint{font-size:12px;color:var(--muted)}

footer{margin-top:26px;color:var(--muted);font-size:13px}

@media(max-width:920px){.layout{flex-direction:column}.col.small{order:2}}

  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <h1>Galaxy Portfolio — Manager</h1>
      <div class="actions">
        <button id="newCatBtn" class="btn">+ New Category</button>
        <button id="openPublic" class="ghost">Open Public Page</button>
      </div>
    </div><div class="layout">
  <div class="col small">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:800;color:var(--muted)">Categories</div>
      <div class="drag-hint">Drag images to reorder inside category</div>
    </div>
    <div id="categories" class="cat-list" style="margin-top:12px">Loading...</div>
  </div>

  <div class="col">
    <div id="editorArea">
      <div class="editor" id="catEditor" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:900;color:var(--accent)" id="eTitle">Category</div>
            <div class="small-muted" id="eId">doc: -</div>
          </div>
          <div style="display:flex;gap:8px">
            <button id="saveCat" class="btn">Save</button>
            <button id="deleteCat" class="ghost">Delete</button>
          </div>
        </div>

        <label>Title</label>
        <input id="inputTitle" type="text" />
        <label>Description</label>
        <textarea id="inputDesc"></textarea>

        <label style="margin-top:14px">Add images</label>
        <div class="dropzone" id="dropzone">Drop image(s) here or <input id="fileInput" type="file" accept="image/*" multiple style="display:inline-block;margin-left:6px"></div>
        <div class="small-muted">Uploaded images are stored in Firebase Storage and added to the <code>images</code> subcollection. A <strong>rank</strong> field is maintained to control ordering. Lower rank = earlier (used for cover).</div>

        <div style="margin-top:12px;font-weight:800;color:var(--muted);">Images</div>
        <div id="imagesGrid" class="images-grid" style="margin-top:10px">No images loaded.</div>

        <div style="margin-top:12px;display:flex;gap:10px;align-items:center">
          <button id="applyOrdering" class="btn">Save Order</button>
          <button id="setCoverBtn" class="btn">Set selected as cover</button>
          <div class="small-muted">Cover is defined by lowest <code>rank</code>. The public page should use <code>.orderBy('rank')</code> to pick the cover reliably. (See note below.)</div>
        </div>
      </div>

      <div id="emptyState" style="color:var(--muted);">Select a category from the left to manage it. You can create a new one with the <strong>New Category</strong> button.</div>
    </div>
  </div>
</div>

<footer>
  <div><strong>Important:</strong> This manager will add/update documents in your existing Firestore structure. It is designed to be compatible with your current public page, but to reliably use the cover image you must set your public page to order images by the <code>rank</code> value. See instructions below.</div>
  <div style="margin-top:10px">Security note: this manager performs writes and storage deletes. Restrict access by using Firebase Authentication and Firestore/Storage security rules, or host it behind an admin-only route.</div>
  <pre id="howto" style="background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:12px;color:var(--muted);font-size:13px;overflow:auto">

How it works (short): • Categories = documents in collection: portfolio.

Each document may have fields: title, description. • Images = documents in portfolio/{catId}/images with fields:

url (string) - public HTTP URL from Firebase Storage

filename (string) - storage filename (for delete)

rank (number) - controls ordering; lower = earlier

caption (string, optional)

createdAt (timestamp)


To make your existing public page reliably use the chosen cover, change this line in your public code (old): db.collection('portfolio').doc(docId).collection('images').limit(1).get() Replace with (recommended): db.collection('portfolio').doc(docId).collection('images').orderBy('rank').limit(1).get()

This manager will set ranks automatically. By default newly uploaded images get rank = current_max_rank + 1. Use "Set as cover" to assign rank = 0 (it will bump other ranks if needed).

Security: Use Firebase Auth + Rules to restrict writes/deletes; App Check is enabled client-side but enforce rules server-side if needed. </pre> </footer>

  </div>  <!-- Firebase SDKs: app, firestore, storage, app-check -->  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-check-compat.js"></script>  <script src="https://www.google.com/recaptcha/api.js?render=6Ld395IrAAAAAIvG4gyf0vUJeI_jKOsI9XVn0jUx"></script>  <script>
    // CONFIG
    const firebaseConfig = {
      apiKey: "AIzaSyBV7Jg0BVzeCNQW9oiIiNItnejUsjj2DhA",
      authDomain: "squadvertex2007.firebaseapp.com",
      projectId: "squadvertex2007",
      storageBucket: "squadvertex2007.appspot.com",
      messagingSenderId: "168905083514",
      appId: "1:168905083514:web:c8bbe2ce9f87800a0f09c3"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const storage = firebase.storage();

    // App Check
    try { const appCheckProvider = new firebase.appCheck.ReCaptchaV3Provider('6Ld395IrAAAAAIvG4gyf0vUJeI_jKOsI9XVn0jUx'); firebase.appCheck().activate(appCheckProvider, true); console.info('App Check ready'); } catch(e){console.warn('App Check fail',e)}

    // UI refs
    const categoriesEl = document.getElementById('categories');
    const newCatBtn = document.getElementById('newCatBtn');
    const openPublic = document.getElementById('openPublic');
    const catEditor = document.getElementById('catEditor');
    const emptyState = document.getElementById('emptyState');
    const inputTitle = document.getElementById('inputTitle');
    const inputDesc = document.getElementById('inputDesc');
    const saveCat = document.getElementById('saveCat');
    const deleteCat = document.getElementById('deleteCat');
    const imagesGrid = document.getElementById('imagesGrid');
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const applyOrdering = document.getElementById('applyOrdering');
    const setCoverBtn = document.getElementById('setCoverBtn');
    const eTitle = document.getElementById('eTitle');
    const eId = document.getElementById('eId');

    let categories = [];
    let selectedCat = null; // {id, title, description}
    let currentImages = []; // [{id, url, filename, rank, caption}]

    // Helper: render categories list
    async function loadCategories(){
      categoriesEl.innerHTML = '<div style="color:var(--muted)">Loading...</div>';
      try{
        const snap = await db.collection('portfolio').get();
        categories = snap.docs.map(d => ({ id: d.id, ...(d.data()||{}) }));
        renderCategoryList();
      }catch(e){ categoriesEl.innerHTML = '<div style="color:#ff8a8a">Failed to load</div>'; console.error(e); }
    }

    function renderCategoryList(){
      categoriesEl.innerHTML = '';
      if (!categories.length) { categoriesEl.innerHTML = '<div style="color:var(--muted)">No categories yet.</div>'; return; }
      categories.forEach(cat => {
        const div = document.createElement('div'); div.className = 'cat-item';
        const thumb = document.createElement('img'); thumb.src = 'https://dummyimage.com/300x200/121824/99a7bf.png&text=...';
        // fetch first image as small cover (rank-ordered if rank exists)
        db.collection('portfolio').doc(cat.id).collection('images').orderBy('rank').limit(1).get().then(s => {
          if (!s.empty) thumb.src = s.docs[0].data().url;
        }).catch(() => {});
        const meta = document.createElement('div'); meta.className = 'meta';
        const t = document.createElement('div'); t.className='t'; t.textContent = cat.title || cat.id;
        const d = document.createElement('div'); d.className='d'; d.textContent = (cat.description || '').slice(0,120);
        meta.appendChild(t); meta.appendChild(d);
        div.appendChild(thumb); div.appendChild(meta);
        div.onclick = ()=> selectCategory(cat.id);
        categoriesEl.appendChild(div);
      });
    }

    // Select category
    async function selectCategory(catId){
      selectedCat = categories.find(c=>c.id===catId) || {id:catId};
      // fetch latest doc data
      const doc = await db.collection('portfolio').doc(catId).get();
      const data = doc.exists ? (doc.data()||{}) : {};
      selectedCat = { id: catId, title: data.title||'', description: data.description||'' };
      eTitle.textContent = selectedCat.title || '(untitled)';
      eId.textContent = 'doc: ' + selectedCat.id;
      inputTitle.value = selectedCat.title;
      inputDesc.value = selectedCat.description;
      catEditor.style.display = 'block'; emptyState.style.display = 'none';
      await loadImagesForCategory(catId);
    }

    async function loadImagesForCategory(catId){
      imagesGrid.innerHTML = '<div style="color:var(--muted)">Loading images...</div>';
      try{
        const snap = await db.collection('portfolio').doc(catId).collection('images').orderBy('rank').get();
        currentImages = snap.docs.map(d=>({ id:d.id, ...(d.data()||{}) }));
        renderImagesGrid();
      }catch(e){ imagesGrid.innerHTML = '<div style="color:#ff8a8a">Failed to load images</div>'; console.error(e); }
    }

    function renderImagesGrid(){
      imagesGrid.innerHTML = '';
      if (!currentImages.length) { imagesGrid.innerHTML = '<div style="color:var(--muted)">No images yet.</div>'; return; }
      currentImages.forEach((img, idx)=>{
        const card = document.createElement('div'); card.className='img-card'; card.draggable=true; card.dataset.index=idx; card.dataset.id=img.id;
        card.addEventListener('dragstart', onDragStart);
        card.addEventListener('dragover', ev=>{ ev.preventDefault(); card.style.outline='2px dashed rgba(255,255,255,0.06)'; });
        card.addEventListener('dragleave', ev=>{ card.style.outline='none'; });
        card.addEventListener('drop', onDrop);

        const im = document.createElement('img'); im.src = img.url; im.alt = img.filename || img.id;
        const controls = document.createElement('div'); controls.className='controls';
        const rankChip = document.createElement('div'); rankChip.className='chip'; rankChip.textContent='rank: ' + (img.rank||0);
        const setBtn = document.createElement('button'); setBtn.className='btn'; setBtn.style.padding='6px 8px'; setBtn.textContent='Set cover'; setBtn.onclick = ()=> setAsCover(img.id);
        const delBtn = document.createElement('button'); delBtn.className='ghost'; delBtn.style.padding='6px 8px'; delBtn.textContent='Delete'; delBtn.onclick = ()=> deleteImage(img.id, img.url);
        controls.appendChild(rankChip); controls.appendChild(setBtn); controls.appendChild(delBtn);
        card.appendChild(im); card.appendChild(controls);
        imagesGrid.appendChild(card);
      });
    }

    // Drag & drop handlers
    let dragSrcIndex = null;
    function onDragStart(e){ dragSrcIndex = Number(e.currentTarget.dataset.index); }
    function onDrop(e){
      e.preventDefault();
      const dst = Number(e.currentTarget.dataset.index);
      if (dragSrcIndex === null || dst === dragSrcIndex) { dragSrcIndex = null; renderImagesGrid(); return; }
      // reorder currentImages
      const moved = currentImages.splice(dragSrcIndex,1)[0];
      currentImages.splice(dst,0,moved);
      // re-render with updated indices
      currentImages.forEach((it,i)=>{ /* display order only, actual DB update on Save Order */ });
      renderImagesGrid();
      dragSrcIndex = null;
    }

    // Save category fields
    saveCat.onclick = async ()=>{
      if (!selectedCat) return alert('Select a category');
      const t = inputTitle.value.trim(); const d = inputDesc.value.trim();
      try{
        await db.collection('portfolio').doc(selectedCat.id).set({ title:t, description:d }, { merge:true });
        // update local list
        const idx = categories.findIndex(c=>c.id===selectedCat.id);
        if (idx>=0){ categories[idx].title = t; categories[idx].description = d; } else categories.push({id:selectedCat.id,title:t,description:d});
        renderCategoryList();
        eTitle.textContent = t||'(untitled)';
        alert('Saved');
      }catch(e){ console.error(e); alert('Save failed'); }
    };

    deleteCat.onclick = async ()=>{
      if (!selectedCat) return; if (!confirm('Delete category and ALL images? This is permanent.')) return;
      try{
        // delete all images first
        const imgsSnap = await db.collection('portfolio').doc(selectedCat.id).collection('images').get();
        const batch = db.batch();
        imgsSnap.docs.forEach(d=> batch.delete(d.ref));
        // delete doc
        batch.delete(db.collection('portfolio').doc(selectedCat.id));
        await batch.commit();
        // NOTE: storage files remain unless explicitly deleted — we did not delete storage here to avoid accidental removal
        categories = categories.filter(c=>c.id!==selectedCat.id);
        selectedCat = null; currentImages = [];
        renderCategoryList(); renderImagesGrid(); catEditor.style.display='none'; emptyState.style.display='block';
        alert('Category deleted (images metadata removed).\nStorage files may still exist; delete them manually if needed.');
      }catch(e){ console.error(e); alert('Delete failed'); }
    };

    // New category
    newCatBtn.onclick = async ()=>{
      const id = prompt('Enter document ID for new category (no spaces, lowercase recommended):');
      if (!id) return; try{ await db.collection('portfolio').doc(id).set({ title:'New Category', description:'' }); await loadCategories(); selectCategory(id); }catch(e){console.error(e);alert('Create failed')}
    };

    // File upload handling
    fileInput.onchange = (ev)=> handleFiles(ev.target.files);
    dropzone.ondrop = (ev)=>{ ev.preventDefault(); handleFiles(ev.dataTransfer.files); }
    dropzone.ondragover = (ev)=>{ ev.preventDefault(); }

    async function handleFiles(files){
      if (!selectedCat) return alert('Select a category first');
      const arr = Array.from(files);
      for (const f of arr){
        try{
          const filename = Date.now() + '_' + f.name.replace(/\s+/g,'_');
          const ref = storage.ref().child(`portfolio/${selectedCat.id}/images/${filename}`);
          const task = ref.put(f);
          // simple progress
          task.on('state_changed', snap=>{}, err=>{console.error(err)}, async ()=>{
            const url = await ref.getDownloadURL();
            // Determine rank = max rank + 1
            const maxRank = currentImages.reduce((m,it)=> Math.max(m, (typeof it.rank==='number'?it.rank:0)), 0);
            const newData = { url, filename, rank: maxRank + 1, caption:'', createdAt: firebase.firestore.FieldValue.serverTimestamp() };
            const docRef = await db.collection('portfolio').doc(selectedCat.id).collection('images').add(newData);
            currentImages.push({ id: docRef.id, ...newData });
            renderImagesGrid();
          });
        }catch(e){console.error(e);alert('Upload failed');}
      }
    }

    // delete image (also delete storage file)
    async function deleteImage(imgId, url){ if (!confirm('Delete this image (including storage file)?')) return; try{
      // remove firestore doc
      await db.collection('portfolio').doc(selectedCat.id).collection('images').doc(imgId).delete();
      // attempt storage delete
      try{ const ref = storage.refFromURL(url); await ref.delete(); }catch(e){ console.warn('Storage delete failed, maybe public URL or already removed', e); }
      // remove from currentImages
      currentImages = currentImages.filter(i=>i.id!==imgId);
      renderImagesGrid();
    }catch(e){console.error(e); alert('Delete failed'); } }

    // Set as cover -> set rank=0 and increment others
    async function setAsCover(imgId){
      if (!confirm('Set this image as cover (will set its rank to 0, and increase others by +1)?')) return;
      try{
        // fetch current images snapshot
        const ref = db.collection('portfolio').doc(selectedCat.id).collection('images');
        const snap = await ref.get();
        const batch = db.batch();
        // increase rank for all existing
        snap.docs.forEach(d=>{
          const data = d.data() || {};
          const currentRank = typeof data.rank === 'number' ? data.rank : 0;
          batch.update(d.ref, { rank: currentRank + 1 });
        });
        // set chosen to rank 0
        batch.update(ref.doc(imgId), { rank: 0 });
        await batch.commit();
        // refresh
        await loadImagesForCategory(selectedCat.id);
        alert('Set as cover');
      }catch(e){ console.error(e); alert('Failed to set cover'); }
    }

    // Save order: push currentImages array order into DB ranks (0..n-1)
    applyOrdering.onclick = async ()=>{
      if (!selectedCat) return alert('Select a category');
      try{
        const ref = db.collection('portfolio').doc(selectedCat.id).collection('images');
        const batch = db.batch();
        currentImages.forEach((it, idx)=>{ const docRef = ref.doc(it.id); batch.update(docRef, { rank: idx + 1 }); });
        await batch.commit();
        alert('Ordering saved');
        await loadImagesForCategory(selectedCat.id);
      }catch(e){ console.error(e); alert('Failed to save order'); }
    };

    // Open public page
    openPublic.onclick = ()=>{ window.open(window.location.pathname.replace(/manager.*$/,'') || '/', '_blank'); };

    // initial load
    loadCategories();
  </script>
</body>
</html>