<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>About Team Galaxy â€” Realistic Orbit Playground</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Poppins:wght@300;500&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-1:#071018;
      --panel: rgba(12,18,26,0.55);
      --accent: #64c2ff;
      --muted: #9fcff6;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018 0%, #081428 60%);color:#eaf7ff;font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial}
    .top-bar{height:72px;display:flex;align-items:center;justify-content:space-between;padding:0 18px;background:rgba(6,12,18,0.45);backdrop-filter: blur(6px);position:sticky;top:0;z-index:40;border-bottom:1px solid rgba(255,255,255,0.03)}
    .logo{display:flex;align-items:center;gap:12px;font-weight:700;font-family:'Montserrat',sans-serif;color:#fff;cursor:pointer}
    .logo img{height:42px;filter:drop-shadow(0 6px 18px rgba(36,160,255,0.08))}
    .nav {display:flex;gap:12px;align-items:center}
    .nav button{background:transparent;border:0;color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
    .nav button:hover{color:var(--accent);background:rgba(100,194,255,0.06)}

    /* HERO: container blends with page */
    .hero-wrap {position:relative;height:420px;margin:18px auto 28px;max-width:1200px;padding:12px;box-sizing:border-box}
    .playground-card {position:relative;height:100%;border-radius:14px;overflow:hidden;background:linear-gradient(180deg, rgba(6,10,18,0.48), rgba(3,6,12,0.58));box-shadow:0 18px 60px rgba(5,10,20,0.7), inset 0 -40px 80px rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.03)}
    
    /* single canvas is background (blended) */
    .play-canvas {position:absolute;inset:0;display:block;mix-blend-mode:screen;opacity:0.95;filter:contrast(1.02) saturate(1.02) blur(0.25px);pointer-events:none}

    /* center Earth (emoji) - DOM element for crispness and accessibility */
    .orbit-center {position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:6;display:flex;align-items:center;justify-content:center;pointer-events:auto}
    .earth {
      width:128px;height:128px;border-radius:50%;display:flex;align-items:center;justify-content:center;
      font-size:72px;line-height:1;cursor:default;
      /* rim and depth */
      box-shadow:
        0 18px 40px rgba(4,12,28,0.6),
        inset -8px -6px 30px rgba(0,0,0,0.45),
        0 6px 18px rgba(100,160,255,0.06);
      border:1px solid rgba(255,255,255,0.04);
      -webkit-user-select:none; user-select:none;
      transform-origin:center center;
      transition:transform .22s cubic-bezier(.2,.9,.3,1);
    }
    .earth:focus{outline:2px solid rgba(100,194,255,0.16);transform:translate(-50%,-50%) scale(1.02)}
    .earth .emoji {filter:drop-shadow(0 6px 18px rgba(0,0,0,0.5)); text-shadow:0 2px 8px rgba(0,0,0,0.35);}

    /* subtle orbit ring overlay */
    .orbit-ring {position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:420px;height:420px;border-radius:50%;pointer-events:none;z-index:4;mix-blend-mode:overlay;opacity:0.35}
    .orbit-ring svg{width:100%;height:100%}

    /* HUD */
    .hud {position:absolute;right:18px;top:14px;z-index:18;background:linear-gradient(180deg, rgba(8,14,20,0.56), rgba(6,10,16,0.56));padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);display:flex;gap:10px;align-items:center;backdrop-filter:blur(6px)}
    .hud .btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:var(--muted);cursor:pointer;font-weight:600}
    .hud .btn:hover{background:rgba(100,194,255,0.08);color:#fff}
    .score {font-weight:700;color:#dff8ff}
    .small-muted{font-size:0.85rem;color:#bfeaff;opacity:0.95}

    /* responsive tweaks */
    @media (max-width:900px){ .earth{width:96px;height:96px;font-size:56px} .orbit-ring{width:320px;height:320px} .hero-wrap{height:360px} }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="logo" onclick="location.href='dashboard.html'">
      <img src="https://dl.dropboxusercontent.com/scl/fi/ulfs6ygkeyvr4mar8bkuz/galaxwbewh.png?rlkey=jq9buj80ny6et6jfbfpiuf14l&st=lwkqobqi&dl=0" alt="logo">
      Team Galaxy
    </div>
    <div class="nav">
      <button onclick="location.href='posts.html'">Posts</button>
      <button onclick="location.href='community_chat.html'">Community</button>
      <button onclick="location.href='about_us.html'">About</button>
    </div>
  </div>

  <!-- HERO with single canvas blended into page -->
  <div class="hero-wrap">
    <div class="playground-card" id="playgroundCard" aria-label="Orbit playground">
      <canvas id="playCanvas" class="play-canvas" aria-hidden="true"></canvas>

      <!-- Earth emoji (DOM for crispness, accessibility) -->
      <div class="orbit-center" role="img" aria-label="Earth. Click the area to spawn satellites">
        <div class="earth" id="earthEl" tabindex="0">
          <span class="emoji" aria-hidden="true">ðŸŒŽ</span>
        </div>
      </div>

      <!-- decorative orbit ring (SVG) blended into background -->
      <div class="orbit-ring" aria-hidden="true">
        <svg viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
          <defs>
            <linearGradient id="g1" x1="0" x2="1">
              <stop offset="0" stop-color="#64c2ff" stop-opacity="0.06"/>
              <stop offset="0.5" stop-color="#a6f0ff" stop-opacity="0.06"/>
              <stop offset="1" stop-color="#64c2ff" stop-opacity="0.02"/>
            </linearGradient>
          </defs>
          <ellipse cx="100" cy="100" rx="86" ry="42" fill="none" stroke="url(#g1)" stroke-width="2"/>
          <ellipse cx="100" cy="100" rx="54" ry="26" fill="none" stroke="rgba(255,255,255,0.02)" stroke-width="1"/>
        </svg>
      </div>

      <!-- HUD -->
      <div class="hud" role="status" aria-live="polite">
        <div>
          <div class="score" id="collected">Collected: 0</div>
          <div class="small-muted" id="highscore">High: 0</div>
        </div>
        <div style="width:8px"></div>
        <div>
          <button class="btn" id="btnSpawn">Spawn</button>
          <button class="btn" id="btnClear">Clear</button>
          <button class="btn" id="btnAuto">Auto: Off</button>
        </div>
      </div>
    </div>
  </div>

  <!-- rest of your page (kept simple here) -->
  <main style="max-width:1100px;margin:0 auto;padding:12px">
    <h1 style="color:#fab84f;margin-top:6px">About Team Galaxy</h1>
    <section style="background:rgba(10,14,20,0.6);padding:18px;border-radius:12px;margin-top:12px">
      <!-- ... keep your content ... -->
      <p style="color:#cfefff">Team Galaxy shines on the competitive stage... (content unchanged)</p>
    </section>
  </main>

  <script>
  (function(){
    // --- Config & state ---
    const canvas = document.getElementById('playCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    const playground = document.getElementById('playgroundCard');
    const earthEl = document.getElementById('earthEl');
    const collectedEl = document.getElementById('collected');
    const highscoreEl = document.getElementById('highscore');
    const btnSpawn = document.getElementById('btnSpawn');
    const btnClear = document.getElementById('btnClear');
    const btnAuto = document.getElementById('btnAuto');

    const LS_COL = 'galaxy_collected_v3';
    const LS_HIGH = 'galaxy_high_v3';
    const LS_AUTO = 'galaxy_auto_v3';

    let DPR = Math.max(1, window.devicePixelRatio || 1);
    let W=0,H=0;
    let collected = parseInt(localStorage.getItem(LS_COL)) || 0;
    let high = parseInt(localStorage.getItem(LS_HIGH)) || 0;
    let autoMode = localStorage.getItem(LS_AUTO) === '1';
    let orbs = []; // satellites
    let pops = []; // particle pops
    let last = performance.now();
    let nextId = 1;
    const MAX_ORBS = 30;

    // rarities
    const ORB_TYPES = [
      { name:'common', chance:0.75, size:10, score:1, color:'#8EE7FF' },
      { name:'uncommon', chance:0.18, size:14, score:3, color:'#FFD57B' },
      { name:'rare', chance:0.06, size:18, score:6, color:'#B8FF9A' },
      { name:'epic', chance:0.01, size:22, score:12, color:'#FF9AD6' }
    ];

    // audio
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    function ensureAudio(){ if (!audioCtx) audioCtx = new AudioCtx(); }
    function playTone(freq=420, dur=0.08){
      try{
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine'; o.frequency.value = freq;
        g.gain.value = 0;
        o.connect(g); g.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        g.gain.linearRampToValueAtTime(0.12, now + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
        o.start(now); o.stop(now + dur + 0.02);
      }catch(e){}
    }

    // helpers
    function rand(a,b){ return a + Math.random()*(b-a); }
    function pickType(){
      const r=Math.random(); let s=0;
      for(const t of ORB_TYPES){ s+=t.chance; if(r<=s) return t; } return ORB_TYPES[0];
    }
    function hexToRgb(hex){ const s=hex.replace('#',''); return { r:parseInt(s.slice(0,2),16), g:parseInt(s.slice(2,4),16), b:parseInt(s.slice(4,6),16) }; }

    // resize canvas to element, DPR aware
    function resize(){
      const rect = playground.getBoundingClientRect();
      W = Math.max(200, Math.floor(rect.width));
      H = Math.max(160, Math.floor(rect.height));
      canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
      canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      // center Earth DOM precisely
      const earthRect = earthEl.getBoundingClientRect();
      // no need to reposition DOM, CSS handles it via transform: translate(-50%,-50%)
    }
    window.addEventListener('resize', resize);

    // spawn satellite at screen coordinates (clientX, clientY)
    function spawnOrbAt(clientX, clientY){
      if (orbs.length >= MAX_ORBS) return;
      const rect = playground.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      // relative coordinates inside playground
      const dx = clientX - cx;
      const dy = clientY - cy;
      let radius = Math.hypot(dx,dy);
      const minRadius = Math.max(72, Math.min(rect.width, rect.height)/6);
      const maxRadius = Math.min(rect.width, rect.height)/2 - 30;
      radius = Math.max(minRadius, Math.min(maxRadius, radius));
      const angle = Math.atan2(dy,dx);
      // angular velocity: smaller radius -> faster orbit
      const baseSpeed = 0.9 / Math.sqrt(Math.max(1, radius/90));
      const speed = (Math.random() < 0.5 ? 1 : -1) * baseSpeed * (0.6 + Math.random()*0.9);
      const type = pickType();
      const orb = {
        id: nextId++,
        angle, radius, speed,
        size: type.size * (0.9 + Math.random()*0.2),
        color: type.color, score: type.score, rarity: type.name,
        rotation: Math.random()*Math.PI*2,
        rotSpeed: (Math.random()*0.9-0.45)*0.02
      };
      orbs.push(orb);
      playTone(210, 0.06);
    }

    // spawn a small burst near center
    function burst(n=3){
      const rect = playground.getBoundingClientRect();
      for(let i=0;i<n;i++){
        const x = rect.left + rect.width/2 + rand(-120,120);
        const y = rect.top + rect.height/2 + rand(-90,90);
        spawnOrbAt(x,y);
      }
    }

    // hit test with forgiving radius (touch-friendly)
    function hitTest(x,y){
      let best=null, bestD=Infinity;
      for(const o of orbs){
        // compute screen position for orb
        const rect = playground.getBoundingClientRect();
        const cx = rect.width/2, cy = rect.height/2;
        const ox = cx + o.radius * Math.cos(o.angle);
        const oy = cy + o.radius * Math.sin(o.angle);
        const d = Math.hypot(x - ox, y - oy);
        const hitR = Math.max(18, o.size*1.6);
        if(d <= hitR && d < bestD){ best = o; bestD = d; }
      }
      return best;
    }

    function collectOrb(o){
      if(!o) return;
      // spawn particle pop
      spawnPopForOrb(o);
      // award
      collected += o.score;
      if (collected > high){ high = collected; localStorage.setItem(LS_HIGH, high); flashHigh(); }
      localStorage.setItem(LS_COL, collected);
      collectedEl.textContent = 'Collected: ' + collected;
      // remove orb
      orbs = orbs.filter(x => x.id !== o.id);
      playTone(360 + o.score*48, 0.12);
    }

    // particle pop
    function spawnPopForOrb(o){
      const rect = playground.getBoundingClientRect();
      const cx = rect.width/2, cy = rect.height/2;
      const x = cx + o.radius * Math.cos(o.angle);
      const y = cy + o.radius * Math.sin(o.angle);
      const rgb = hexToRgb(o.color);
      const parts = [];
      const count = Math.min(28, Math.round(6 + o.size*1.2));
      for(let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        parts.push({
          vx: Math.cos(ang)*(0.6 + Math.random()*2.6),
          vy: Math.sin(ang)*(0.6 + Math.random()*2.6),
          size: Math.random()* (o.size*0.6) + 0.6,
          color: `rgba(${rgb.r},${rgb.g},${rgb.b},`
        });
      }
      pops.push({ x,y, parts, life:1, lifeMax:1, speed:42 + o.size*6 });
    }

    // update & draw
    function updateAndDraw(now){
      const dt = (now - last) / 1000;
      last = now;
      // clear canvas with translucent fill for trails
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(6,8,10,0.12)';
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      // draw faint background stars (subtle; blended with mix-blend-mode)
      drawBackgroundStars(now);

      // draw orbits & satellites
      drawOrbits(now, dt);

      // draw pops
      drawPops(now, dt);

      // fade pops list
      pops = pops.filter(p => p.life > 0.02);

      requestAnimationFrame(updateAndDraw);
    }

    // background stars visual (simple, low cost)
    let starSeed = [];
    function initStars(){
      starSeed.length = 0;
      const count = Math.round((W*H)/26000);
      for(let i=0;i<count;i++){
        starSeed.push({
          x: Math.random()*W, y: Math.random()*H,
          s: Math.random()*1.6 + 0.3, tw: Math.random()*Math.PI*2
        });
      }
    }
    function drawBackgroundStars(now){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(const s of starSeed){
        const a = 0.22 + 0.18*Math.abs(Math.sin(now/1200 + s.tw));
        ctx.fillStyle = `rgba(200,220,255,${a})`;
        ctx.beginPath(); ctx.ellipse(s.x, s.y, s.s, s.s, 0,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    function drawOrbits(now, dt){
      const rect = playground.getBoundingClientRect();
      const cx = rect.width/2, cy = rect.height/2;

      // subtle orbital path lines (light)
      ctx.save();
      ctx.strokeStyle = 'rgba(160,200,255,0.03)';
      ctx.lineWidth = 1;
      for(const o of orbs){
        ctx.beginPath();
        ctx.ellipse(cx, cy, o.radius, o.radius, 0, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();

      // draw satellites front-to-back
      for(const o of orbs){
        o.angle += o.speed * dt;
        o.rotation += o.rotSpeed;
        const x = cx + o.radius * Math.cos(o.angle);
        const y = cy + o.radius * Math.sin(o.angle);

        // satellite body with small solar panels
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(o.rotation);
        // glow
        ctx.beginPath();
        const g = ctx.createRadialGradient(0,0,o.size*0.2, 0,0,o.size*3.2);
        const rgb = hexToRgb(o.color);
        g.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.85)`);
        g.addColorStop(0.25, `rgba(${rgb.r},${rgb.g},${rgb.b},0.28)`);
        g.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0.0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.ellipse(0,0, o.size*1.8, o.size*0.9, 0,0,Math.PI*2); ctx.fill();

        // body
        ctx.fillStyle = '#11161d';
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.roundRect(-o.size*0.6, -o.size*0.4, o.size*1.2, o.size*0.8, o.size*0.18); ctx.fill(); ctx.stroke();

        // panel left
        ctx.save();
        ctx.translate(-o.size*1.05,0); ctx.rotate(Math.sin(now/600 + o.id)*0.05);
        ctx.fillStyle = '#091521';
        ctx.fillRect(-o.size*0.55, -o.size*0.42, o.size*0.6, o.size*0.86);
        // solar lines
        ctx.strokeStyle = 'rgba(60,120,140,0.12)';
        ctx.lineWidth = 1;
        for(let i=-2;i<=2;i++){ ctx.beginPath(); ctx.moveTo(-o.size*0.5 + i* (o.size*0.1), -o.size*0.4); ctx.lineTo(-o.size*0.5 + i* (o.size*0.1), o.size*0.4); ctx.stroke(); }
        ctx.restore();

        // panel right
        ctx.save();
        ctx.translate(o.size*1.05,0); ctx.rotate(Math.sin(now/700 + o.id)*0.06);
        ctx.fillStyle = '#091521';
        ctx.fillRect(-o.size*0.05, -o.size*0.42, o.size*0.6, o.size*0.86);
        ctx.strokeStyle = 'rgba(60,120,140,0.12)';
        ctx.lineWidth = 1;
        for(let i=-2;i<=2;i++){ ctx.beginPath(); ctx.moveTo(-o.size*0.0 + i* (o.size*0.1), -o.size*0.4); ctx.lineTo(-o.size*0.0 + i* (o.size*0.1), o.size*0.4); ctx.stroke(); }
        ctx.restore();

        // little antenna
        ctx.beginPath(); ctx.moveTo(o.size*0.64, -o.size*0.02); ctx.lineTo(o.size*0.98, -o.size*0.6); ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.stroke();
        ctx.beginPath(); ctx.arc(o.size*0.98, -o.size*0.6, 1.6, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.fill();

        // colored badge for rarity
        if(o.rarity === 'rare' || o.rarity === 'epic'){
          ctx.beginPath(); ctx.arc(o.size*0.6, -o.size*0.36, o.size*0.36, 0, Math.PI*2);
          ctx.fillStyle = o.color; ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.font = `${Math.max(7, o.size*0.28)}px sans-serif`;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(o.rarity[0].toUpperCase(), o.size*0.6, -o.size*0.36);
        }

        ctx.restore();
      }
    }

    function drawPops(now, dt){
      ctx.save();
      for(let i=pops.length-1;i>=0;i--){
        const p = pops[i];
        p.life -= dt / 400; // fade speed
        const alpha = Math.max(0, p.life / p.lifeMax);
        const sx = p.x, sy = p.y;
        for(const part of p.parts){
          const px = sx + part.vx * (1 - alpha) * p.speed;
          const py = sy + part.vy * (1 - alpha) * p.speed;
          const s = Math.max(0.6, part.size * alpha);
          ctx.fillStyle = part.color + (0.85 * alpha) + ')';
          ctx.beginPath(); ctx.ellipse(px, py, s, s, 0,0,Math.PI*2); ctx.fill();
        }
        if (p.life <= 0) pops.splice(i,1);
      }
      ctx.restore();
    }

    // main loop
    function loop(now){
      requestAnimationFrame(loop);
      updateAndDraw(now);
    }

    function updateAndDraw(now){
      const t = now;
      const dt = (now - last) || 16;
      last = now;

      // clear bg with subtle blend to preserve glow trails
      ctx.clearRect(0,0,W,H);

      // draw semi-transparent backplate to create motion-trail smear
      ctx.fillStyle = 'rgba(6,8,12,0.16)';
      ctx.fillRect(0,0,W,H);

      // draw stars + subtle nebula
      drawBackgroundStars(now);

      // draw orbits and satellites
      drawOrbits(now, dt/1000);

      // draw pops on top
      drawPops(now, dt);

      // subtle vignette
      drawVignette();
    }

    // draw vignette
    function drawVignette(){
      const g = ctx.createRadialGradient(W/2, H/2, Math.max(W,H)/6, W/2, H/2, Math.max(W,H)/1.0);
      g.addColorStop(0,'rgba(255,255,255,0)');
      g.addColorStop(1,'rgba(0,0,0,0.20)');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    }

    // background stars: lower count, soft
    let stars = [];
    function initStars(){
      stars = [];
      const count = Math.max(18, Math.round((W*H)/70000));
      for(let i=0;i<count;i++) stars.push({ x:Math.random()*W, y:Math.random()*H, s:Math.random()*1.6+0.4, phase:Math.random()*Math.PI*2 });
    }
    function drawBackgroundStars(now){
      ctx.save(); ctx.globalCompositeOperation = 'lighter';
      for(const s of stars){
        const a = 0.22 + 0.18*Math.abs(Math.sin(now/1200 + s.phase));
        ctx.fillStyle = `rgba(210,235,255,${a})`;
        ctx.beginPath(); ctx.ellipse(s.x, s.y, s.s, s.s, 0,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    // utilities
    function flashHigh(){
      highscoreEl.style.transition = 'transform .24s ease,color .24s ease';
      highscoreEl.style.transform = 'scale(1.06)';
      highscoreEl.style.color = '#fff';
      setTimeout(()=>{ highscoreEl.style.transform=''; highscoreEl.style.color=''; }, 420);
    }

    // pointer handling (canvas is background; clicks on playground area spawn or collect)
    function toLocalCoords(clientX, clientY){
      const rect = playground.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handlePointerDown(e){
      if(e.pointerType === 'mouse' && e.button !== 0) return; // only left click
      const p = toLocalCoords(e.clientX, e.clientY);
      // first try hit test on orbs
      const found = hitTest(p.x, p.y);
      if(found){ collectOrb(found); return; }
      // else spawn at pointer
      spawnOrbAt(e.clientX, e.clientY);
    }

    // wire pointer
    playground.addEventListener('pointerdown', handlePointerDown);

    // controls
    btnSpawn.addEventListener('click', ()=> burst(3));
    btnClear.addEventListener('click', ()=> { orbs = []; pops = []; ctx.clearRect(0,0,W,H); });
    btnAuto.addEventListener('click', ()=> {
      autoMode = !autoMode; localStorage.setItem(LS_AUTO, autoMode ? '1' : '0');
      btnAuto.textContent = 'Auto: ' + (autoMode ? 'On' : 'Off');
    });

    // auto spawn loop
    let autoAcc = 0;
    setInterval(()=>{
      if(autoMode && orbs.length < 10 && Math.random() < 0.6) burst(1);
    }, 1400);

    // keyboard: space spawns near center
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){ e.preventDefault(); const rect = playground.getBoundingClientRect(); spawnOrbAt(rect.left + rect.width/2 + rand(-90,90), rect.top + rect.height/2 + rand(-60,60)); }
    });

    // init
    function init(){
      DPR = Math.max(1, window.devicePixelRatio || 1);
      resize();
      initStars();
      // warmup orbs
      const rect = playground.getBoundingClientRect();
      for(let i=0;i<7;i++){ spawnOrbAt(rect.left + rect.width/2 + rand(-140,140), rect.top + rect.height/2 + rand(-90,90)); }
      collectedEl.textContent = 'Collected: ' + collected;
      highscoreEl.textContent = 'High: ' + high;
      btnAuto.textContent = 'Auto: ' + (autoMode? 'On' : 'Off');
      last = performance.now();
      requestAnimationFrame(loop);
      // resume audio on first user interaction (mobile)
      document.addEventListener('pointerdown', ()=> { if(!audioCtx) try{ ensureAudio(); }catch(e){} }, { once:true });
    }

    // polyfill for roundRect if absent
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x+r, y);
        this.arcTo(x+w, y, x+w, y+h, r);
        this.arcTo(x+w, y+h, x, y+h, r);
        this.arcTo(x, y+h, x, y, r);
        this.arcTo(x, y, x+w, y, r);
        this.closePath();
      };
    }

    // start & handle resize gracefully
    window.addEventListener('load', init);
    window.addEventListener('resize', ()=>{ resize(); initStars(); });

    // persist collected periodically
    setInterval(()=> localStorage.setItem(LS_COL, collected), 2500);

    // keep last pointer for smoother mobile tap
    let lastPointer = null;
  })();
  </script>
</body>
</html>
