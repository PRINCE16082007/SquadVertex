<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Text Animation with Drift Car & Sparkles</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@900&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%);
            font-family: 'Poppins', sans-serif;
            user-select: none;
        }
        #container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
            cursor: grab;
        }
        #container:active {
            cursor: grabbing;
        }
        canvas {
            display: block;
            outline: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Include Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/fonts/helvetiker_regular.typeface.json"></script>

    <script>
        (() => {

            const container = document.getElementById('container');

            // Scene, Camera and Renderer setup
            const scene = new THREE.Scene();

            // Camera setup
            const camera = new THREE.PerspectiveCamera(
                55,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            camera.position.set(0, 30, 100);

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setClearColor(0x000000, 1);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls for user interaction
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.minDistance = 20;
            controls.maxDistance = 200;
            controls.maxPolarAngle = Math.PI / 2.1;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x1f1f1f);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0x00fff6, 1.8);
            directionalLight1.position.set(50, 50, 50);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0x005577, 0.8);
            directionalLight2.position.set(-50, 30, -40);
            scene.add(directionalLight2);

            // Spotlight for dramatic effect
            const spotLight = new THREE.SpotLight(0x00efff, 1.2);
            spotLight.position.set(0, 150, 100);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.3;
            spotLight.decay = 2;
            spotLight.distance = 400;
            spotLight.castShadow = true;
            scene.add(spotLight);

            // Ground Plane with subtle glow reflection
            const groundGeometry = new THREE.CircleGeometry(120, 64);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x001111,
                roughness: 1,
                metalness: 0.1,
                emissive: 0x001322,
                emissiveIntensity: 0.8,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -6;
            ground.receiveShadow = true;
            scene.add(ground);

            // 3D Text with gradient texture and shader noise for subtle glitch effect

            const loader = new THREE.FontLoader();
            let textMesh;

            function createGradientTexture() {
                // Create a canvas gradient texture for the text
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 256;

                const ctx = canvas.getContext('2d');

                // Gradient with multiple stops
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                gradient.addColorStop(0, '#00ffe7');
                gradient.addColorStop(0.2, '#33ccff');
                gradient.addColorStop(0.5, '#4aeeff');
                gradient.addColorStop(0.7, '#00ffe7');
                gradient.addColorStop(1, '#33ffc1');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Sparkle effect overlay - small white spots with glow
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = Math.random() * 3 + 0.5;

                    const sparkleGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    sparkleGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                    sparkleGradient.addColorStop(0.6, 'rgba(255,255,255,0.1)');
                    sparkleGradient.addColorStop(1, 'rgba(255,255,255,0)');

                    ctx.fillStyle = sparkleGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;

                return texture;
            }

            // Custom shader material with subtle noise to create glitch flicker effect on text
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform sampler2D baseTexture;
                uniform float time;
                varying vec2 vUv;

                // Simple 2D noise function
                float rand(vec2 n) { 
                    return fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vec4 color = texture2D(baseTexture, vUv);

                    // Apply flickering glitch effect randomly on horizontal stripes
                    float line = step(0.9, fract(vUv.y * 30.0 + time * 5.0));
                    float flicker = rand(vec2(vUv.x * 10.0, time)) * 0.4;

                    color.rgb += line * flicker;

                    // Slight color offset for RGB split glitch effect
                    float glitch = step(0.95, fract(vUv.y * 60.0 + time * 20.0));
                    vec2 offset = vec2(0.002 * sin(time * 50.0), 0.0);
                    vec4 glitchColorR = texture2D(baseTexture, vUv + offset);
                    vec4 glitchColorG = texture2D(baseTexture, vUv);
                    vec4 glitchColorB = texture2D(baseTexture, vUv - offset);

                    color.r = mix(color.r, glitchColorR.r, glitch);
                    color.g = mix(color.g, glitchColorG.g, glitch);
                    color.b = mix(color.b, glitchColorB.b, glitch);

                    gl_FragColor = color;
                }
            `;

            // Text geometry params
            const textOptions = {
                font: null,  // to be loaded
                size: 20,
                height: 5,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 1.8,
                bevelSize: 0.8,
                bevelOffset: 0,
                bevelSegments: 4,
                bevelEnabled: true,
            };

            let textMaterial;
            let startTime = performance.now();

            loader.load('https://cdn.jsdelivr.net/npm/three@0.152.2/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                textOptions.font = font;
                const geometry = new THREE.TextGeometry('AWESOME', textOptions);

                geometry.center(); // Center the geometry

                const gradientTexture = createGradientTexture();

                textMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: { value: gradientTexture },
                        time: { value: 0 }
                    },
                    vertexShader,
                    fragmentShader,
                    transparent: false,
                    side: THREE.FrontSide,
                });

                textMesh = new THREE.Mesh(geometry, textMaterial);
                textMesh.castShadow = true;
                textMesh.receiveShadow = true;
                
                scene.add(textMesh);
            });

            // Sparkle particles on or around the text using Points

            const sparkleParticleCount = 350;
            let sparkleGeometry = new THREE.BufferGeometry();
            const sparklePositions = new Float32Array(sparkleParticleCount * 3);
            const sparkleSizes = new Float32Array(sparkleParticleCount);

            for(let i=0; i < sparkleParticleCount; i++){
                // Spread sparkles roughly around text dimensions (centered at origin)
                sparklePositions[i*3] = (Math.random() - 0.5) * 50;         // x
                sparklePositions[i*3 + 1] = (Math.random() - 0.1) * 40;     // y
                sparklePositions[i*3 + 2] = (Math.random() - 0.5) * 20;     // z
                sparkleSizes[i] = 0.15 + Math.random() * 0.4;
            }
            sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
            sparkleGeometry.setAttribute('size', new THREE.BufferAttribute(sparkleSizes, 1));

            // Sparkle texture from circle via canvas
            function createSparkleTexture() {
                const size = 64;
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');

                const center = size/2;
                const gradient = ctx.createRadialGradient(center, center, 0, center, center, center);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.4, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);

                return new THREE.CanvasTexture(canvas);
            }

            const sparkleTexture = createSparkleTexture();

            const sparkleMaterial = new THREE.PointsMaterial({
                size: 1.4,
                sizeAttenuation: true,
                map: sparkleTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.8,
                color: new THREE.Color(0x00ffe7)
            });

            const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
            sparkles.frustumCulled = false;
            scene.add(sparkles);

            // Create simple 3D car geometry - basic shapes, animate drifting orbit around the text

            const car = new THREE.Group();

            // Car body
            const bodyGeo = new THREE.BoxGeometry(14, 4, 6);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x0077ff, 
                roughness: 0.3, 
                metalness: 0.8, 
                emissive: 0x003366,
                emissiveIntensity: 0.5,
                flatShading: false
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            body.position.y = 3;
            car.add(body);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(8, 3, 5);
            const cabinMat = new THREE.MeshStandardMaterial({
                color: 0x004d99,
                opacity: 0.9,
                transparent: true,
                roughness: 0.1,
                metalness: 0.9,
                emissive: 0x005599,
                emissiveIntensity: 0.4,
                flatShading: false
            });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 5.2, 0);
            car.add(cabin);

            // Wheels function
            function createWheel() {
                const wheelGeo = new THREE.CylinderGeometry(1.7, 1.7, 1.3, 24);
                const wheelMat = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    roughness: 0.7,
                    metalness: 0.5,
                    flatShading: true,
                });
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                wheel.receiveShadow = true;
                return wheel;
            }

            const wheelFL = createWheel();
            wheelFL.position.set(-5, 1, 3.8);

            const wheelFR = createWheel();
            wheelFR.position.set(5, 1, 3.8);

            const wheelBL = createWheel();
            wheelBL.position.set(-5, 1, -3.8);

            const wheelBR = createWheel();
            wheelBR.position.set(5, 1, -3.8);

            car.add(wheelFL);
            car.add(wheelFR);
            car.add(wheelBL);
            car.add(wheelBR);

            car.position.set(35, 0, 0);
            car.castShadow = true;
            scene.add(car);

            // Drift animation parameters
            const driftRadius = 35;
            let driftAngle = 0;

            // Add subtle glowing trail behind car (using Points)
            const trailGeometry = new THREE.BufferGeometry();
            const trailPointsCount = 40;
            const trailPositions = new Float32Array(trailPointsCount * 3);
            for(let i=0; i < trailPointsCount; i++) {
                trailPositions[i * 3] = car.position.x;
                trailPositions[i * 3 + 1] = car.position.y;
                trailPositions[i * 3 + 2] = car.position.z;
            }
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));

            const trailTexture = sparkleTexture; // reuse sparkle texture

            const trailMaterial = new THREE.PointsMaterial({
                size: 1.3,
                map: trailTexture,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                color: 0x00aaff,
            });

            const trailPoints = new THREE.Points(trailGeometry, trailMaterial);
            scene.add(trailPoints);

            // Animate trail positions like a smooth curve curve following the car
            let trailPositionsArray = [];
            for(let i=0; i < trailPointsCount; i++) {
                trailPositionsArray.push(new THREE.Vector3(car.position.x, car.position.y, car.position.z));
            }

            // Animate

            function animate(time) {
                const elapsed = (time - startTime) * 0.001;

                controls.update();

                // Animate text - rotate slow with a little bounce scale and glow pulsation
                
                if(textMesh && textMaterial){
                    textMesh.rotation.y = elapsed * 0.4;
                    textMesh.rotation.x = Math.sin(elapsed * 0.7) * 0.07;

                    // Subtle swell / bounce scale
                    const scale = 1 + 0.02 * Math.sin(elapsed * 8);
                    textMesh.scale.set(scale, scale, scale);

                    // update time uniform for glitch
                    textMaterial.uniforms.time.value = elapsed;
                }

                // Animate sparkles - pulse size
                const sizes = sparkleGeometry.attributes.size.array;
                for (let i = 0; i < sparkleParticleCount; i++) {
                    sizes[i] = 0.3 + 0.2 * Math.sin(elapsed * 10 + i);
                }
                sparkleGeometry.attributes.size.needsUpdate = true;

                // Animate drifting car
                driftAngle += 0.011; // speed of drift

                // Drift circle path (wavy to simulate drifting)
                const driftX = Math.cos(driftAngle) * driftRadius + Math.sin(driftAngle * 3) * 3;
                const driftZ = Math.sin(driftAngle) * driftRadius + Math.cos(driftAngle * 3) * 2;
                car.position.set(driftX, 0, driftZ);

                // Car faces the direction of travel with a little oscillation (simulate drifting)
                const direction = new THREE.Vector3(
                    -Math.sin(driftAngle),
                    0,
                    Math.cos(driftAngle)
                );
                const targetAngle = Math.atan2(direction.x, direction.z);
                car.rotation.y = targetAngle + Math.sin(elapsed * 10) * 0.18;

                // Wheels rotation for spinning effect
                const rotateSpeed = 0.3;
                wheelFL.rotation.x += rotateSpeed;
                wheelFR.rotation.x += rotateSpeed;
                wheelBL.rotation.x += rotateSpeed;
                wheelBR.rotation.x += rotateSpeed;

                // Update trail: shift positions and add current car position at front
                trailPositionsArray.pop();
                trailPositionsArray.unshift(new THREE.Vector3(car.position.x, car.position.y+1.8, car.position.z));
                for(let i=0; i < trailPointsCount; i++){
                    trailPositions[i*3] = trailPositionsArray[i].x;
                    trailPositions[i*3+1] = trailPositionsArray[i].y + Math.sin(elapsed*20 + i) * 0.06; // slight vertical shimmer
                    trailPositions[i*3+2] = trailPositionsArray[i].z;
                }
                trailGeometry.attributes.position.needsUpdate = true;

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            requestAnimationFrame(animate);
        })();
    </script>
</body>
</html>

