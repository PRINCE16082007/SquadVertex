<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PDF Editor — Multiple Images with Smart Guides</title>
<style>
  body{ margin:0; font-family:Inter,system-ui,Roboto,Arial; background:#071025; color:#e6f3ff; }
  h2{ color:#7cc1ff; margin:0; }
  .controls{ display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  input[type=file]{ padding:8px; border-radius:6px; background:#071428; color:#fff; border:1px solid rgba(255,255,255,0.03); }
  button{ padding:8px 12px; border-radius:8px; border:none; background:#7cc1ff; color:#032033; font-weight:600; cursor:pointer; }
  #workspace{ 
    display:flex; 
    flex-direction: column;
    height: 100vh;
    gap: 16px;
  }
  #pdf-panel{ 
    width: 100%;
    height: calc(100% - 300px);
    background:#fff; 
    border-radius:8px; 
    overflow:hidden; 
    box-shadow:0 8px 30px rgba(0,0,0,0.6);
  }
  #pdf-container{ 
    position:relative; 
    width:100%; 
    height:100%; 
    background:#fff;
  }
  #pdf-canvas{ 
    display:block; 
    width:100%; 
    height:auto; 
    background:#fff; 
  }
  img.editable-image{ 
    position:absolute; 
    cursor:move; 
    border:2px dashed rgba(124,193,255,0.9); 
    box-sizing:border-box; 
    user-select: none;
  }
  #bottom-controls{
    display:flex;
    gap:16px;
    height: 300px;
    padding: 16px;
    background:#071025;
    border-radius:8px;
  }
  #image-list{ 
    flex:1; 
    min-width:200px;
    background:#041422; 
    border-radius:8px; 
    padding:10px;
    overflow:auto;
  }
  #controls{ 
    flex:1; 
    min-width:200px;
    background:#041422; 
    border-radius:8px; 
    padding:10px;
    display:none;
  }
  #log-window{ 
    flex:1; 
    min-width:200px;
    background:#041422; 
    border-radius:8px; 
    padding:10px;
    overflow:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
    font-size:12px;
    color:#bfe1ff;
  }
  .field{ margin-bottom:8px; color:#cde6ff; }
  label{ color:#bfe7ff; margin-right:6px; }
  input[type=number]{ width:80px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:#071428; color:#e6f7ff; }
  .log-time{ color:#80bde6; margin-right:8px; }
  .log-error{ color:#ff9b9b; }
  .log-info{ color:#cfeeff; }
  .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:#9fc8ea; padding:6px 10px; border-radius:6px; cursor:pointer; }
  .image-item{ display:flex; align-items:center; padding:5px; margin:5px 0; background:#0a1a2a; border-radius:6px; }
  .image-thumb{ width:40px; height:40px; object-fit:cover; margin-right:10px; border-radius:4px; }
  .page-selector{ padding:4px; border-radius:4px; background:#071428; color:#e6f7ff; border:1px solid rgba(255,255,255,0.04); }
  #guides-container{ 
    position:absolute; 
    top:0; 
    left:0; 
    width:100%; 
    height:100%; 
    pointer-events:none;
    z-index:10;
  }
  .guide-line{ 
    position:absolute; 
    background:rgba(124,193,255,0.5); 
    z-index:9;
  }
  .guide-horizontal{ 
    height:1px; 
    border:0; 
    border-top:1px dashed rgba(124,193,255,0.7);
  }
  .guide-vertical{ 
    width:1px; 
    border:0; 
    border-left:1px dashed rgba(124,193,255,0.7);
  }
  .guide-text{ 
    position:absolute; 
    background:rgba(10,20,30,0.8); 
    color:#7cc1ff; 
    padding:2px 4px; 
    border-radius:4px; 
    font-size:10px; 
    font-family:ui-monospace, monospace;
    z-index:11;
  }
  .corner-handle{ 
    position:absolute; 
    width:10px; 
    height:10px; 
    background:#7cc1ff; 
    border:1px solid #032033; 
    border-radius:50%; 
    z-index:15;
  }
  .corner-tl{ top:-5px; left:-5px; }
  .corner-tr{ top:-5px; right:-5px; }
  .corner-bl{ bottom:-5px; left:-5px; }
  .corner-br{ bottom:-5px; right:-5px; }
  .corner-resize{ 
    cursor: nwse-resize; 
  }
  .corner-resize-tr{ 
    cursor:nesw-resize; 
  }
  .corner-resize-bl{ 
    cursor:nesw-resize; 
  }
  .corner-resize-br{ 
    cursor: nwse-resize; 
  }
</style>
</head>
<body>

<h2>PDF Editor — Multiple Images with Smart Guides</h2>

<div class="controls">
  <input id="pdf-upload" type="file" accept="application/pdf" />
  <input id="image-upload" type="file" accept="image/*" />
  <button id="prev-page">Previous Page</button>
  <button id="next-page">Next Page</button>
  <span id="page-number">Page 1</span>
  <button id="save-pdf-btn">Save PDF with Images</button>
  <button id="clear-logs" class="btn-ghost">Clear logs</button>
  <div style="color:#9fc8ea;">Upload PDF first → then images. Drag to place. Click image to edit.</div>
</div>

<div id="workspace">
  <div id="pdf-panel">
    <div id="pdf-container">
      <canvas id="pdf-canvas"></canvas>
      <div id="guides-container"></div>
    </div>
  </div>

  <div id="bottom-controls">
    <div id="image-list" style="display:none;"></div>
    <div id="controls">
      <div class="field">
        <label>Page:</label>
        <select id="image-page">
          <!-- Options will be added when PDF is loaded -->
        </select>
      </div>
      <div class="field">
        <label>X:</label><input type="number" id="pos-x" value="50"/>
        <label style="margin-left:8px;">Y:</label><input type="number" id="pos-y" value="50"/>
      </div>
      <div class="field">
        <label>Width:</label><input type="number" id="img-width" value="160"/>
        <label style="margin-left:8px;">Height:</label><input type="number" id="img-height" value="160"/>
      </div>
      <div class="field">
        <button id="update-btn">Update Image</button>
        <button id="scale-300" class="btn-ghost">Scale for 300 DPI</button>
        <button id="delete-image" class="btn-ghost">Delete Image</button>
      </div>
    </div>
    <div id="log-window" aria-live="polite"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.min.js "></script>
<script>
// Wrap entire script in DOMContentLoaded to ensure DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  /* -------- logger -------- */
  const logWindow = document.getElementById('log-window');
  function now(){ return new Date().toLocaleTimeString(); }
  function log(msg, type='info'){
    const row = document.createElement('div');
    row.className = 'log-row';
    const t = document.createElement('span');
    t.className = 'log-time';
    t.textContent = '['+now()+']';
    const m = document.createElement('span');
    m.className = (type==='error' ? 'log-error' : 'log-info');
    m.textContent = ' ' + msg;
    row.appendChild(t); row.appendChild(m);
    logWindow.appendChild(row);
    logWindow.scrollTop = logWindow.scrollHeight;
    console[type==='error' ? 'error' : 'log'](`[${now()}] ${msg}`);
  }
  document.getElementById('clear-logs').addEventListener('click', ()=>{ logWindow.innerHTML=''; log('Logs cleared'); });

  /* -------- pdf.js ---------- */
  const pdfjsLib = window['pdfjs-dist/build/pdf'];
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.worker.min.js ';

  /* -------- state -------- */
  let pdfDoc = null;
  let originalPdfBytes = null;
  let currentPage = 1;
  let scale = 1.5;
  let images = []; // Array of image objects
  let activeImageId = null; // ID of the currently selected image
  let guidesContainer = document.getElementById('guides-container');
  let cornerHandles = [];

  /* -------- DOM refs -------- */
  const canvas = document.getElementById('pdf-canvas');
  const ctx = canvas.getContext('2d');
  const pdfContainer = document.getElementById('pdf-container');
  const controls = document.getElementById('controls');
  const imageList = document.getElementById('image-list');

  /* -------- dynamic loader for pdf-lib -------- */
  async function loadScript(url, timeout = 12000){
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      let done = false;
      s.src = url;
      s.async = true;
      s.onload = () => { done = true; resolve(s); };
      s.onerror = (e) => { if (!done) { done = true; reject(new Error('Script load failed: ' + url)); } };
      document.head.appendChild(s);
      setTimeout(()=>{ if (!done) reject(new Error('Timeout loading script: ' + url)); }, timeout);
    });
  }
  let PDFLibReady = false;
  async function ensurePDFLib(){
    if (PDFLibReady && window.PDFLib) return window.PDFLib;
    if (window.PDFLib) { PDFLibReady = true; log('PDFLib already present'); return window.PDFLib; }
    const cdns = [
      'https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js ',
      'https://unpkg.com/pdf-lib/dist/pdf-lib.min.js '
    ];
    let lastErr = null;
    for (const url of cdns){
      try{
        log('Attempting to load pdf-lib from: ' + url);
        await loadScript(url, 12000);
        if (window.PDFLib) { PDFLibReady = true; log('Loaded pdf-lib from: ' + url); return window.PDFLib; }
      } catch(err){ lastErr = err; log('Failed to load from ' + url + ' — ' + (err.message||err), 'error'); }
    }
    if (window.PDFLib) { PDFLibReady = true; return window.PDFLib; }
    throw new Error('Unable to load pdf-lib library: ' + (lastErr ? lastErr.message : 'unknown'));
  }

  /* -------- PDF load & render -------- */
  document.getElementById('pdf-upload').addEventListener('change', async (e) => {
    try {
      const file = e.target.files[0];
      if (!file) { log('No PDF chosen', 'error'); return; }

      // Make two copies: one for pdf.js (which may detach it), one for pdf-lib
      const ab = await file.arrayBuffer();
      originalPdfBytes = ab.slice(0); // Safe copy for pdf-lib
      const pdfJsBuffer = ab.slice(0); // Separate copy for pdf.js

      // FIX: Correct parameter for pdf.js - must use 'data' property
      pdfDoc = await pdfjsLib.getDocument({ data: pdfJsBuffer }).promise;
      log(`PDF loaded: ${file.name} (${Math.max(0, Math.round(ab.byteLength/1024))} KB)`);

      // Update page options
      const pageOptions = document.getElementById('image-page');
      if (!pageOptions) {
        throw new Error('Page selector element not found');
      }
      pageOptions.innerHTML = '';
      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const option = document.createElement('option');
        option.value = i - 1; // 0-based
        option.textContent = `Page ${i}`;
        pageOptions.appendChild(option);
      }

      currentPage = 1;
      await renderPage(currentPage);
      document.getElementById('page-number').textContent = `Page ${currentPage}`;

      // Clear existing images
      images = [];
      activeImageId = null;
      updateImageList();
      controls.style.display = 'block';
      log('Ready for new images');
    } catch(err){ log('PDF load error: ' + (err.message || err), 'error'); }
  });

  async function renderPage(pageNum){
    try {
      if (!pdfDoc) throw new Error('No PDF loaded');
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      canvas.style.width = viewport.width + 'px';
      canvas.style.height = viewport.height + 'px';
      const renderContext = { canvasContext: ctx, viewport };
      await page.render(renderContext).promise;
      log(`Page ${pageNum} rendered — canvas ${viewport.width}×${viewport.height}px`);
      pdfContainer.style.width = viewport.width + 'px';
      pdfContainer.style.height = viewport.height + 'px';

      // Update image visibility for current page
      updatePageVisibility();

      // Hide guides and corner handles
      clearGuides();
      clearCornerHandles();
    } catch(err){ log('Render error: ' + (err.message || err), 'error'); }
  }

  /* -------- Image handling -------- */
  function updatePageVisibility() {
    // Hide all images
    images.forEach(img => {
      img.element.style.display = 'none';
    });

    // Show images for current page
    images.forEach(img => {
      if (img.page === currentPage - 1) {
        img.element.style.display = 'block';
      }
    });
  }

  function createImageItem(image) {
    const item = document.createElement('div');
    item.className = 'image-item';
    item.innerHTML = `
      <img src="${image.element.src}" class="image-thumb" />
      <div>
        <span>${image.file.name}</span>
        <select class="page-selector" data-id="${image.id}">
          ${Array.from(document.getElementById('image-page').options).map(opt => 
            `<option value="${opt.value}" ${image.page == opt.value ? 'selected' : ''}>${opt.text}</option>`
          ).join('')}
        </select>
        <button class="select-image" data-id="${image.id}">Select</button>
        <button class="delete-image" data-id="${image.id}">X</button>
      </div>
    `;
    return item;
  }

  function updateImageList() {
    imageList.innerHTML = '';
    if (images.length === 0) {
      imageList.style.display = 'none';
      return;
    }

    imageList.style.display = 'block';
    images.forEach(img => {
      const item = createImageItem(img);
      imageList.appendChild(item);
    });

    // Add event listeners to image list items
    document.querySelectorAll('.select-image').forEach(btn => {
      btn.addEventListener('click', (e) => {
        activeImageId = e.target.dataset.id;
        updateControlValuesForActiveImage();
        showCornerHandles();
        updateGuides();
        controls.style.display = 'block';
      });
    });

    document.querySelectorAll('.delete-image').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const id = e.target.dataset.id;
        const image = images.find(img => img.id === id);
        if (image) {
          pdfContainer.removeChild(image.element);
          images = images.filter(img => img.id !== id);
          updateImageList();
          if (activeImageId === id) {
            activeImageId = null;
            clearGuides();
            clearCornerHandles();
            controls.style.display = 'none';
          }
          log('Image deleted');
        }
      });
    });

    document.querySelectorAll('.page-selector').forEach(sel => {
      sel.addEventListener('change', (e) => {
        const id = e.target.dataset.id;
        const page = parseInt(e.target.value);
        const image = images.find(img => img.id === id);
        if (image) {
          image.page = page;
          updatePageVisibility();
          log(`Image moved to page ${page + 1}`);
        }
      });
    });
  }

  document.getElementById('image-upload').addEventListener('change', async (e) => {
    try {
      const file = e.target.files[0];
      if (!file) { log('No image chosen', 'error'); return; }
      if (!pdfDoc) { alert('Upload a PDF first.'); log('Tried to upload image before PDF', 'error'); return; }

      // Create a new image object
      const imgId = `img-${Date.now()}-${Math.random().toString(36).slice(2)}`;
      const url = URL.createObjectURL(file);
      const imgElement = document.createElement('img');
      imgElement.className = 'editable-image';
      imgElement.src = url;
      imgElement.style.left = '50px';
      imgElement.style.top = '50px';
      imgElement.style.width = '160px';
      imgElement.style.height = '160px';
      imgElement.dataset.id = imgId;
      pdfContainer.appendChild(imgElement);
      makeDraggable(imgElement);

      // Get image bytes and mime type
      const { bytes: imgBytes, mime } = await getImageBytesReliable(file);

      // Add to images array
      images.push({
        id: imgId,
        file: file,
        element: imgElement,
        page: currentPage - 1, // 0-based
        x: 50,
        y: 50,
        width: 160,
        height: 160,
        bytes: imgBytes,
        mime: mime
      });

      // Update UI
      updateImageList();
      activeImageId = imgId;
      updateControlValuesForActiveImage();
      showCornerHandles();
      updateGuides();
      controls.style.display = 'block';
      log(`Image loaded: ${file.name} (${file.type || 'unknown'})`);
    } catch(err){ log('Image upload error: ' + (err.message || err), 'error'); }
  });

  function makeDraggable(img) {
    let dragging = false, offsetX = 0, offsetY = 0;
    img.addEventListener('mousedown', (ev) => {
      dragging = true;
      const rect = img.getBoundingClientRect();
      offsetX = ev.clientX - rect.left;
      offsetY = ev.clientY - rect.top;
      ev.preventDefault();
      activeImageId = img.dataset.id;
      updateControlValuesForActiveImage();
      showCornerHandles();
      updateGuides();
    });
    window.addEventListener('mousemove', (ev) => {
      if (!dragging) return;
      const contRect = pdfContainer.getBoundingClientRect();
      const left = ev.clientX - contRect.left - offsetX;
      const top = ev.clientY - contRect.top - offsetY;
      img.style.left = Math.max(0, Math.round(left)) + 'px';
      img.style.top = Math.max(0, Math.round(top)) + 'px';
      updateControlValuesForActiveImage();
      updateGuides();
    });
    window.addEventListener('mouseup', () => {
      dragging = false;
      updateGuides();
    });
    img.addEventListener('click', () => {
      activeImageId = img.dataset.id;
      updateControlValuesForActiveImage();
      showCornerHandles();
      updateGuides();
      controls.style.display = 'block';
    });
  }
  function updateControlValuesForActiveImage() {
    if (!activeImageId) return;
    const image = images.find(img => img.id === activeImageId);
    if (!image) return;

    document.getElementById('image-page').value = image.page;
    document.getElementById('pos-x').value = image.x;
    document.getElementById('pos-y').value = image.y;
    document.getElementById('img-width').value = image.width;
    document.getElementById('img-height').value = image.height;
  }

  document.getElementById('update-btn').addEventListener('click', () => {
    if (!activeImageId) return;
    const image = images.find(img => img.id === activeImageId);
    if (!image) return;

    const x = parseInt(document.getElementById('pos-x').value) || 0;
    const y = parseInt(document.getElementById('pos-y').value) || 0;
    const w = parseInt(document.getElementById('img-width').value) || 100;
    const h = parseInt(document.getElementById('img-height').value) || 100;
    const page = parseInt(document.getElementById('image-page').value) || 0;

    image.x = x;
    image.y = y;
    image.width = w;
    image.height = h;
    image.page = page;

    image.element.style.left = x + 'px';
    image.element.style.top = y + 'px';
    image.element.style.width = w + 'px';
    image.element.style.height = h + 'px';

    updateImageList();
    updateGuides();
    log(`Image moved/resized -> x:${x}, y:${y}, w:${w}, h:${h}, page:${page + 1}`);
  });

  document.getElementById('scale-300').addEventListener('click', () => {
    if (!activeImageId) return;
    const image = images.find(img => img.id === activeImageId);
    if (!image) return;

    const newWidth = image.width * 1.8;
    const newHeight = image.height * 1.8;

    image.width = newWidth;
    image.height = newHeight;
    image.element.style.width = newWidth + 'px';
    image.element.style.height = newHeight + 'px';

    updateControlValuesForActiveImage();
    updateGuides();
    log('Scaled image visually for higher DPI (approx 300 DPI).');
  });

  /* -------- Image conversion helpers -------- */
  async function getImageBytesReliable(file) {
    try {
      const type = (file.type || '').toLowerCase();
      const ab = await file.arrayBuffer();
      if (type === 'image/png' || type === 'image/jpeg' || type === 'image/jpg') {
        log('Using original image bytes (no conversion).');
        return { bytes: ensureFreshUint8Array(ab), mime: type || 'image/png' };
      } else {
        log('Converting image to PNG for best-quality embed...');
        const pngBytes = await convertFileToPngBytes(file);
        return { bytes: ensureFreshUint8Array(pngBytes), mime: 'image/png' };
      }
    } catch(err) {
      log('Image conversion error: ' + (err.message || err), 'error');
      throw err;
    }
  }

  async function convertFileToPngBytes(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        try {
          const r = window.devicePixelRatio || 1;
          const scaleFactor = Math.max(1, r * 2);
          const c = document.createElement('canvas');
          c.width = Math.max(1, Math.round(img.naturalWidth * scaleFactor));
          c.height = Math.max(1, Math.round(img.naturalHeight * scaleFactor));
          const cctx = c.getContext('2d');
          cctx.drawImage(img, 0, 0, c.width, c.height);
          const dataURL = c.toDataURL('image/png');
          try { URL.revokeObjectURL(url); } catch(e){}
          resolve(dataURLToUint8Array(dataURL));
        } catch(err) {
          try { URL.revokeObjectURL(url); } catch(e){}
          reject(err);
        }
      };
      img.onerror = (err) => {
        try { URL.revokeObjectURL(url); } catch(e){}
        reject(err || new Error('image load failed'));
      };
      img.src = url;
    });
  }

  function dataURLToUint8Array(dataURL) {
    const base64 = dataURL.split(',')[1];
    const raw = atob(base64);
    const u8 = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) u8[i] = raw.charCodeAt(i);
    return u8;
  }

  /* Make a safe copy of any ArrayBuffer-like input, handles detached buffers */
  function ensureFreshUint8Array(input) {
    if (input instanceof Uint8Array) {
      return input.slice(0);
    } else if (input instanceof ArrayBuffer) {
      try {
        return new Uint8Array(input.slice(0));
      } catch (e) {
        // Fallback to byte-by-byte copy for detached buffers
        const arr = new Uint8Array(input.byteLength);
        for (let i = 0; i < input.byteLength; i++) {
          arr[i] = new Uint8Array(input)[i];
        }
        return arr;
      }
    } else if (ArrayBuffer.isView(input) && input.buffer) {
      try {
        return new Uint8Array(input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength));
      } catch (e) {
        const arr = new Uint8Array(input.byteLength);
        for (let i = 0; i < input.byteLength; i++) {
          arr[i] = input[i];
        }
        return arr;
      }
    } else {
      // Fallback: try to coerce
      return new Uint8Array(input);
    }
  }

  /* -------- Page navigation -------- */
  document.getElementById('prev-page').addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      renderPage(currentPage);
      document.getElementById('page-number').textContent = `Page ${currentPage}`;
    }
  });

  document.getElementById('next-page').addEventListener('click', () => {
    if (currentPage < pdfDoc?.numPages) {
      currentPage++;
      renderPage(currentPage);
      document.getElementById('page-number').textContent = `Page ${currentPage}`;
    }
  });

  /* -------- Smart Guides Implementation -------- */
  function clearGuides() {
    guidesContainer.innerHTML = '';
  }

  function clearCornerHandles() {
    cornerHandles.forEach(handle => {
      if (handle.parentNode) {
        handle.parentNode.removeChild(handle);
      }
    });
    cornerHandles = [];
  }

  function showCornerHandles() {
    if (!activeImageId) return;
    const image = images.find(img => img.id === activeImageId);
    if (!image) return;

    // Remove existing handles
    clearCornerHandles();

    const rect = image.element.getBoundingClientRect();
    const contRect = pdfContainer.getBoundingClientRect();

    // Top-left corner
    const tl = document.createElement('div');
    tl.className = 'corner-handle corner-tl corner-resize';
    tl.style.left = `${rect.left - contRect.left}px`;
    tl.style.top = `${rect.top - contRect.top}px`;
    pdfContainer.appendChild(tl);
    cornerHandles.push(tl);

    // Top-right corner
    const tr = document.createElement('div');
    tr.className = 'corner-handle corner-tr corner-resize-tr';
    tr.style.right = `${contRect.width - (rect.right - contRect.left)}px`;
    tr.style.top = `${rect.top - contRect.top}px`;
    pdfContainer.appendChild(tr);
    cornerHandles.push(tr);

    // Bottom-left corner
    const bl = document.createElement('div');
    bl.className = 'corner-handle corner-bl corner-resize-bl';
    bl.style.left = `${rect.left - contRect.left}px`;
    bl.style.bottom = `${contRect.height - (rect.bottom - contRect.top)}px`;
    pdfContainer.appendChild(bl);
    cornerHandles.push(bl);

    // Bottom-right corner
    const br = document.createElement('div');
    br.className = 'corner-handle corner-br corner-resize-br';
    br.style.right = `${contRect.width - (rect.right - contRect.left)}px`;
    br.style.bottom = `${contRect.height - (rect.bottom - contRect.top)}px`;
    pdfContainer.appendChild(br);
    cornerHandles.push(br);

    // Add resize handlers
    [tl, tr, bl, br].forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        const handleType = handle.className.split(' ')[1];
        startResize(handleType, e);
      });
    });
  }

  function startResize(handleType, e) {
    if (!activeImageId) return;
    const image = images.find(img => img.id === activeImageId);
    if (!image) return;

    const rect = image.element.getBoundingClientRect();
    const contRect = pdfContainer.getBoundingClientRect();
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = image.width;
    const startHeight = image.height;
    const startLeft = parseFloat(image.element.style.left) || 0;
    const startTop = parseFloat(image.element.style.top) || 0;

    function resize(e) {
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      let newWidth = startWidth;
      let newHeight = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;

      switch(handleType) {
        case 'corner-tl':
          newWidth = startWidth - dx;
          newHeight = startHeight - dy;
          newLeft = startLeft + dx;
          newTop = startTop + dy;
          break;
        case 'corner-tr':
          newWidth = startWidth + dx;
          newHeight = startHeight - dy;
          newTop = startTop + dy;
          break;
        case 'corner-bl':
          newWidth = startWidth - dx;
          newHeight = startHeight + dy;
          newLeft = startLeft + dx;
          break;
        case 'corner-br':
          newWidth = startWidth + dx;
          newHeight = startHeight + dy;
          break;
      }

      // Constrain to positive dimensions
      if (newWidth < 10) newWidth = 10;
      if (newHeight < 10) newHeight = 10;

      image.width = newWidth;
      image.height = newHeight;
      image.x = newLeft;
      image.y = newTop;

      image.element.style.left = `${newLeft}px`;
      image.element.style.top = `${newTop}px`;
      image.element.style.width = `${newWidth}px`;
      image.element.style.height = `${newHeight}px`;

      updateControlValuesForActiveImage();
      updateGuides();
    }

    function stopResize() {
      document.removeEventListener('mousemove', resize);
      document.removeEventListener('mouseup', stopResize);
      updateGuides();
    }

    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResize);
  }

  function updateGuides() {
    clearGuides();

    if (!activeImageId) return;
    const image = images.find(img => img.id === activeImageId);
    if (!image) return;

    const rect = image.element.getBoundingClientRect();
    const contRect = pdfContainer.getBoundingClientRect();

    // Get all other images' positions
    const otherImages = images.filter(img => img.id !== activeImageId);
    const allPositions = otherImages.map(img => {
      const imgRect = img.element.getBoundingClientRect();
      return {
        left: imgRect.left - contRect.left,
        right: imgRect.right - contRect.left,
        top: imgRect.top - contRect.top,
        bottom: imgRect.bottom - contRect.top,
        width: img.width,
        height: img.height
      };
    });

    // Add page boundaries
    allPositions.push({
      left: 0,
      right: contRect.width,
      top: 0,
      bottom: contRect.height,
      width: contRect.width,
      height: contRect.height
    });

    // Horizontal guides (top, bottom, center)
    const imageTop = rect.top - contRect.top;
    const imageBottom = rect.bottom - contRect.top;
    const imageCenterY = (imageTop + imageBottom) / 2;
    const imageHeight = rect.height;

    // Vertical guides (left, right, center)
    const imageLeft = rect.left - contRect.left;
    const imageRight = rect.right - contRect.left;
    const imageCenterX = (imageLeft + imageRight) / 2;
    const imageWidth = rect.width;

    // Check for alignment with other objects
    const guideThreshold = 5; // pixels of tolerance for alignment

    // Horizontal guides
    allPositions.forEach(pos => {
      // Top edge alignment
      if (Math.abs(imageTop - pos.top) < guideThreshold) {
        createGuideLine('horizontal', pos.top, `Top: ${pos.top.toFixed(1)}px`);
      }
      // Bottom edge alignment
      if (Math.abs(imageBottom - pos.bottom) < guideThreshold) {
        createGuideLine('horizontal', pos.bottom, `Bottom: ${pos.bottom.toFixed(1)}px`);
      }
      // Center alignment
      if (Math.abs(imageCenterY - ((pos.top + pos.bottom)/2)) < guideThreshold) {
        createGuideLine('horizontal', (pos.top + pos.bottom)/2, `Center: ${((pos.top + pos.bottom)/2).toFixed(1)}px`);
      }
    });

    // Vertical guides
    allPositions.forEach(pos => {
      // Left edge alignment
      if (Math.abs(imageLeft - pos.left) < guideThreshold) {
        createGuideLine('vertical', pos.left, `Left: ${pos.left.toFixed(1)}px`);
      }
      // Right edge alignment
      if (Math.abs(imageRight - pos.right) < guideThreshold) {
        createGuideLine('vertical', pos.right, `Right: ${pos.right.toFixed(1)}px`);
      }
      // Center alignment
      if (Math.abs(imageCenterX - ((pos.left + pos.right)/2)) < guideThreshold) {
        createGuideLine('vertical', (pos.left + pos.right)/2, `Center: ${((pos.left + pos.right)/2).toFixed(1)}px`);
      }
    });

    // Distance measurements between edges
    allPositions.forEach(pos => {
      // Horizontal distance between left edges
      const leftDist = Math.abs(imageLeft - pos.left);
      if (leftDist < 100 && leftDist > guideThreshold) {
        createDistanceText(imageLeft, pos.left, imageTop - 10, `${leftDist.toFixed(1)}px`);
      }

      // Horizontal distance between right edges
      const rightDist = Math.abs(imageRight - pos.right);
      if (rightDist < 100 && rightDist > guideThreshold) {
        createDistanceText(imageRight, pos.right, imageTop - 10, `${rightDist.toFixed(1)}px`);
      }

      // Vertical distance between top edges
      const topDist = Math.abs(imageTop - pos.top);
      if (topDist < 100 && topDist > guideThreshold) {
        createDistanceText(imageLeft - 10, pos.left - 10, imageTop, `${topDist.toFixed(1)}px`, 'vertical');
      }

      // Vertical distance between bottom edges
      const bottomDist = Math.abs(imageBottom - pos.bottom);
      if (bottomDist < 100 && bottomDist > guideThreshold) {
        createDistanceText(imageLeft - 10, pos.left - 10, imageBottom, `${bottomDist.toFixed(1)}px`, 'vertical');
      }
    });
  }

  function createGuideLine(type, position, label = '') {
    const guide = document.createElement('div');
    if (type === 'horizontal') {
      guide.className = 'guide-line guide-horizontal';
      guide.style.top = `${position}px`;
      guide.style.left = '0';
      guide.style.width = '100%';
    } else {
      guide.className = 'guide-line guide-vertical';
      guide.style.left = `${position}px`;
      guide.style.top = '0';
      guide.style.height = '100%';
    }

    guidesContainer.appendChild(guide);

    if (label) {
      const text = document.createElement('div');
      text.className = 'guide-text';
      text.textContent = label;
      if (type === 'horizontal') {
        text.style.top = `${position - 15}px`;
        text.style.left = '5px';
      } else {
        text.style.top = '5px';
        text.style.left = `${position + 5}px`;
      }
      guidesContainer.appendChild(text);
    }
  }

  function createDistanceText(x1, x2, y, text, direction = 'horizontal') {
    const distText = document.createElement('div');
    distText.className = 'guide-text';
    distText.textContent = text;

    if (direction === 'horizontal') {
      distText.style.top = `${y}px`;
      distText.style.left = `${(x1 + x2)/2}px`;
      distText.style.transform = 'translateX(-50%)';
    } else {
      distText.style.top = `${(y1 + y2)/2}px`;
      distText.style.left = `${x1}px`;
      distText.style.transform = 'translateY(-50%)';
    }

    guidesContainer.appendChild(distText);
  }

  /* -------- save/export handler -------- */
  async function robustEmbedAndSave(PDFLib, originalBytes, imageBytes, mime, coords) {
    // Make fresh copies of both PDF bytes and image bytes to avoid any detached buffer problems
    const pdfBytesCopy = ensureFreshUint8Array(originalBytes).buffer;
    const imageBytesSafe = ensureFreshUint8Array(imageBytes);

    const pdfLibDoc = await PDFLib.PDFDocument.load(pdfBytesCopy);
    log('pdf-lib loaded original PDF (safe copy).');

    const page = pdfLibDoc.getPage(coords.pageIndex);
    const { width: pageWidth, height: pageHeight } = page.getSize();
    log(`PDF page size inside save: ${Math.round(pageWidth)}×${Math.round(pageHeight)} pts`);

    let embedded;
    try {
      if (mime === 'image/png') {
        embedded = await pdfLibDoc.embedPng(imageBytesSafe);
        log('Embedded PNG (safe copy).');
      } else if (mime === 'image/jpeg' || mime === 'image/jpg') {
        embedded = await pdfLibDoc.embedJpg(imageBytesSafe);
        log('Embedded JPG (safe copy).');
      } else {
        embedded = await pdfLibDoc.embedPng(imageBytesSafe);
        log('Embedded fallback PNG (safe copy).');
      }
    } catch (err) {
      log('Embed failure — bytes length: ' + (imageBytesSafe ? imageBytesSafe.length : 'unknown'), 'error');
      log('Embed stack: ' + (err && err.message ? err.message : err), 'error');
      throw err;
    }

    page.drawImage(embedded, { x: coords.x, y: coords.y, width: coords.width, height: coords.height });
    log('Image drawn on PDF page (inside robustEmbedAndSave).');

    return pdfLibDoc;
  }

  document.getElementById('save-pdf-btn').addEventListener('click', async () => {
    try {
      if (!pdfDoc) { log('Export failed: No PDF uploaded', 'error'); alert('Upload a PDF first'); return; }
      if (images.length === 0) { log('Export failed: No images placed', 'error'); alert('Place an image first'); return; }
      if (!originalPdfBytes) throw new Error('Original PDF bytes missing');

      log('Starting export process... (ensuring pdf-lib is loaded)');
      const PDFLib = await ensurePDFLib();
      if (!PDFLib) throw new Error('pdf-lib did not initialize');
      log('pdf-lib ready.');

      // Load the PDF once
      const pdfLibDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
      log('pdf-lib loaded original PDF (safe copy).');

      // Process each image
      for (const img of images) {
        const pageIndex = img.page;
        const page = pdfLibDoc.getPage(pageIndex);
        const { width: pageWidth, height: pageHeight } = page.getSize();

        const canvasRect = canvas.getBoundingClientRect();
        const displayW = canvasRect.width, displayH = canvasRect.height;

        const x_pdf = (img.x / displayW) * pageWidth;
        const width_pdf = (img.width / displayW) * pageWidth;
        const y_pdf = pageHeight - ((img.y + img.height) / displayH) * pageHeight;
        const height_pdf = (img.height / displayH) * pageHeight;

        log(`Processing image on page ${pageIndex + 1} -> x:${x_pdf.toFixed(2)}, y:${y_pdf.toFixed(2)}, w:${width_pdf.toFixed(2)}, h:${height_pdf.toFixed(2)}`);

        let embedded;
        if (img.mime === 'image/png') {
          embedded = await pdfLibDoc.embedPng(img.bytes);
          log('Embedded PNG');
        } else if (img.mime === 'image/jpeg' || img.mime === 'image/jpg') {
          embedded = await pdfLibDoc.embedJpg(img.bytes);
          log('Embedded JPG');
        } else {
          embedded = await pdfLibDoc.embedPng(img.bytes);
          log('Embedded fallback PNG');
        }

        page.drawImage(embedded, { x: x_pdf, y: y_pdf, width: width_pdf, height: height_pdf });
        log('Image drawn on PDF page');
      }

      const outBytes = await pdfLibDoc.save({ useObjectStreams: false });
      log(`PDF saved in-memory (${Math.round(outBytes.byteLength/1024)} KB). Preparing download...`);
      const blob = new Blob([outBytes], { type: 'application/pdf' });
      const pdfUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = pdfUrl;
      a.download = 'edited.pdf';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(pdfUrl);
      log('Download triggered — check your Downloads folde